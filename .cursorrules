# CozyChat 项目开发规范

你是一个专业的AI编程助手，正在协助开发CozyChat项目。请严格遵循以下规范：

## 项目概述

CozyChat是一个现代化的AI对话平台，具有以下特点：
- **后端**: Python + FastAPI，模块化AI引擎（OpenAI/Ollama/LM Studio）
- **前端**: React + TypeScript，支持Web和移动端
- **核心功能**: 人格系统、记忆管理、工具调用、语音支持
- **数据库**: PostgreSQL（业务数据）+ ChromaDB/Qdrant（向量数据）+ Redis（缓存）

## 通用规范

### 文件组织

#### 目录结构规范
- 后端代码放在 `backend/` 目录
- 前端代码放在 `frontend/` 目录
- 文档放在 `docs/` 目录
- 配置文件使用 YAML 格式（人格、工具等）
- 环境变量使用 `.env` 文件管理（不提交到Git）

#### 文档组织规范 ⚠️ 重要
**禁止在项目根目录随意创建文档文件！**

- ✅ **允许**：项目根目录只能有 `README.md` 和 `PROGRESS.md`
- ❌ **禁止**：在根目录创建其他 `.md` 文件
- ✅ **必须**：所有其他文档文件必须放在 `docs/` 目录下
- ✅ **建议**：在 `docs/` 下按阶段或功能创建子目录组织文档

**docs 目录结构示例：**
```
docs/
├── setup/              # 配置和安装文档
│   ├── CONFIG.md      # 环境配置指南
│   └── FIXES_SUMMARY.md  # 修复记录
├── troubleshooting/    # 故障排查文档
│   └── QUICK_FIX.md   # 常见问题修复
├── 00-实施路线图.md
├── 01-项目概述.md
├── 02-后端架构设计.md
└── ...
```

### 代码质量
- 编写代码前先理解项目架构（参考 `docs/` 目录）
- 新功能必须有对应的测试用例
- 核心模块测试覆盖率要求 ≥ 80%
- 提交前自动运行 pre-commit hooks 检查
- API变更必须更新文档

### Git提交规范
使用 Conventional Commits 格式：
```
feat(chat): 添加流式响应支持
fix(memory): 修复记忆检索超时问题
docs(api): 更新人格系统API文档
```

## Python开发规范（后端）

### 代码风格
- 遵循 PEP 8，使用 Black 格式化（行长度100）
- 使用 isort 管理导入顺序
- 必须通过 flake8 和 mypy 检查

### 导入顺序
```python
# 1. 标准库
import os
from typing import Dict, List, Optional

# 2. 第三方库
from fastapi import FastAPI, HTTPException
from sqlalchemy.orm import Session

# 3. 本地库
from app.config.config import settings
from app.utils.logger import logger
```

### 类型注解（强制）
```python
# ✅ 好的写法
async def get_user(user_id: str) -> Optional[User]:
    """获取用户信息"""
    pass

def process_messages(
    messages: List[Dict[str, str]],
    options: Optional[Dict[str, Any]] = None
) -> Tuple[str, int]:
    pass

# ❌ 避免的写法
def get_user(user_id):  # 缺少类型注解
    pass
```

### 命名规范
- **类名**: 大驼峰 `UserManager`, `ChatEngine`
- **函数/方法**: 小写+下划线 `get_user()`, `create_session()`
- **常量**: 大写+下划线 `MAX_RETRY`, `DEFAULT_TIMEOUT`
- **变量**: 小写+下划线 `user_id`, `session_data`
- **私有方法**: 下划线开头 `_validate_token()`

### 异步编程
```python
# ✅ 优先使用异步
async def fetch_data(url: str) -> Dict:
    async with httpx.AsyncClient() as client:
        response = await client.get(url)
        return response.json()

# 并发执行
results = await asyncio.gather(
    fetch_user(user_id),
    fetch_sessions(user_id),
    fetch_preferences(user_id)
)

# 超时控制
try:
    result = await asyncio.wait_for(
        slow_operation(),
        timeout=5.0
    )
except asyncio.TimeoutError:
    logger.warning("Operation timed out")
```

### 错误处理
```python
# 使用自定义异常
from app.utils.exceptions import CozyError, AuthenticationError

# 具体异常优先
try:
    user = get_user(user_id)
except UserNotFoundError:
    logger.warning(f"User not found: {user_id}")
    raise HTTPException(status_code=404, detail="User not found")
except DatabaseError as e:
    logger.error(f"Database error: {e}")
    raise HTTPException(status_code=500, detail="Database error")
```

### 日志规范
```python
from app.utils.logger import logger

# 不同级别
logger.debug("详细调试信息")
logger.info("一般信息")
logger.warning("警告信息")
logger.error("错误信息", exc_info=True)  # 包含堆栈

# 结构化日志
logger.info(
    "User login",
    extra={
        "user_id": user_id,
        "ip": request.client.host
    }
)
```

### Docstring格式
```python
class UserManager:
    """用户管理器
    
    负责用户的创建、认证和权限管理。
    
    Attributes:
        db: 数据库会话
        auth_service: 认证服务实例
    """
    
    async def authenticate(
        self,
        username: str,
        password: str
    ) -> Optional[Dict[str, Any]]:
        """用户认证
        
        Args:
            username: 用户名或邮箱
            password: 明文密码
        
        Returns:
            认证成功返回包含token的字典，失败返回None
        
        Raises:
            DatabaseError: 数据库查询失败时抛出
        """
        pass
```

### 项目结构
```
backend/
  app/
    main.py              # FastAPI入口
    config/              # 配置管理
    core/                # 核心业务逻辑
      orchestrator.py    # 核心编排器
      personality/       # 人格系统
      user/              # 用户管理
    engines/             # 引擎层
      ai/                # AI引擎（OpenAI/Ollama/LMStudio）
      memory/            # 记忆管理
      tools/             # 工具系统
      voice/             # 语音引擎（STT/TTS/RealTime）
    models/              # SQLAlchemy模型
    schemas/             # Pydantic模型
    api/v1/              # API路由
    utils/               # 工具函数
```

## React开发规范（前端）

### 技术栈规范

**核心框架**:
- React 18+ (函数组件 + Hooks)
- TypeScript 5+ (严格模式)
- Vite 5+ (构建工具)
- pnpm (包管理器，首选)

**UI组件库**:
- **AI聊天组件**: `@chatui/core` (首选，专为聊天设计，企业级成熟度)
- **通用UI组件**: `antd` (布局、表单、反馈、Drawer等)
- **图标库**: `@ant-design/icons`

**状态管理**:
- **全局状态**: `zustand` (轻量级，首选) 或 `Jotai` (原子化)
- **服务端状态**: `@tanstack/react-query` (数据获取、缓存、乐观更新)
- **表单状态**: `React Hook Form` + `Zod` (表单管理 + 验证)

**样式方案**:
- `@chatui/core`: 聊天组件样式
- `antd`: 通用组件样式
- `tailwindcss`: 原子化CSS（可选，用于自定义样式）
- `CSS Modules`: 作为备选

### 代码风格

- 使用 TypeScript，严格模式
- ESLint + Prettier 自动格式化
- 单引号、分号、2空格缩进
- 必须通过 ESLint 和 TypeScript 检查

### 导入顺序规范

```typescript
// 1. React相关
import React, { useState, useEffect, useCallback } from 'react';

// 2. 第三方库
import { Chat } from '@chatui/core';
import { Button, Drawer } from 'antd';
import { useQuery } from '@tanstack/react-query';

// 3. 本地组件
import { ChatMessage } from '@/components/chat/ChatMessage';
import { Header } from '@/components/layout/Header';

// 4. Hooks
import { useChat } from '@/hooks/useChat';
import { useAuth } from '@/hooks/useAuth';

// 5. 服务
import { chatApi } from '@/services/chat';

// 6. 类型
import type { Message, ChatState } from '@/types/chat';

// 7. 工具函数
import { formatDate } from '@/utils/format';

// 8. 样式
import styles from './ChatPage.module.css';
```

### 组件规范

```typescript
// ✅ 函数组件 + TypeScript接口 + JSDoc注释
/**
 * 聊天消息组件属性
 */
interface ChatMessageProps {
  /** 消息角色 */
  role: 'user' | 'assistant';
  /** 消息内容 */
  content: string;
  /** 时间戳 */
  timestamp: Date;
  /** 是否加载中 */
  loading?: boolean;
  /** 点击回调 */
  onClick?: () => void;
}

/**
 * 聊天消息组件
 * 
 * 显示单条聊天消息，支持用户和AI两种角色。
 * 
 * @example
 * ```tsx
 * <ChatMessage
 *   role="user"
 *   content="Hello, AI!"
 *   timestamp={new Date()}
 * />
 * ```
 */
const ChatMessage: React.FC<ChatMessageProps> = ({
  role,
  content,
  timestamp,
  loading = false,
  onClick,
}) => {
  // 组件实现
  return (
    <div
      className={`${styles.message} ${styles[role]}`}
      data-testid={`${role}-message`}
      onClick={onClick}
    >
      {content}
    </div>
  );
};

export default React.memo(ChatMessage);
export type { ChatMessageProps };
```

**组件最佳实践**:
1. ✅ 使用函数组件和Hooks，避免类组件
2. ✅ Props使用TypeScript接口定义，必须包含JSDoc注释
3. ✅ 导出组件和类型: `export type { ChatMessageProps }; export default ChatMessage;`
4. ✅ 使用React.memo优化性能: `export default React.memo(ChatMessage);`
5. ✅ 使用data-testid用于测试: `<div data-testid="chat-message">...</div>`
6. ✅ 条件渲染: `{isLoading && <Spinner />}` 而不是 `{isLoading ? <Spinner /> : null}`

### ChatUI组件使用规范

```typescript
// src/features/chat/components/ChatContainer/ChatContainer.tsx
import React, { useState, useCallback } from 'react';
import { Chat } from '@chatui/core';
import '@chatui/core/dist/index.css';
import { useChat } from '@/hooks/useChat';
import type { Message } from '@/types/chat';

interface ChatContainerProps {
  /** 会话ID */
  sessionId: string;
  /** 人格ID */
  personalityId: string;
}

/**
 * 聊天容器组件
 * 
 * 使用ChatUI核心组件构建聊天界面。
 */
const ChatContainer: React.FC<ChatContainerProps> = ({
  sessionId,
  personalityId,
}) => {
  const { messages, sendMessage, isLoading } = useChat(sessionId, personalityId);
  
  const handleSend = useCallback(
    async (type: string, val: string) => {
      if (type === 'text' && val.trim()) {
        await sendMessage(val);
      }
    },
    [sendMessage]
  );
  
  return (
    <Chat
      navbar={{
        title: 'CozyChat',
      }}
      messages={messages}
      onSend={handleSend}
      placeholder="输入消息..."
      locale="zh-CN"
    />
  );
};

export default ChatContainer;
```

### Ant Design组件使用规范

```typescript
// src/components/user/HealthRecordDrawer/HealthRecordDrawer.tsx
import React from 'react';
import { Drawer, Tabs, Space } from 'antd';
import { UserOutlined } from '@ant-design/icons';
import type { DrawerProps } from 'antd';

interface HealthRecordDrawerProps {
  /** 是否可见 */
  open: boolean;
  /** 关闭回调 */
  onClose: () => void;
}

/**
 * 健康档案抽屉组件
 * 
 * 使用Ant Design的Drawer组件实现侧边栏。
 */
const HealthRecordDrawer: React.FC<HealthRecordDrawerProps> = ({
  open,
  onClose,
}) => {
  const tabItems = [
    {
      key: 'basic',
      label: '基本信息',
      children: <BasicInfo />,
    },
    {
      key: 'health',
      label: '健康记录',
      children: <HealthRecords />,
    },
  ];
  
  return (
    <Drawer
      title={
        <Space>
          <UserOutlined />
          健康档案
        </Space>
      }
      placement="right"
      width={600}
      open={open}
      onClose={onClose}
      maskClosable={false}
    >
      <Tabs items={tabItems} />
    </Drawer>
  );
};

export default HealthRecordDrawer;
```

### 命名规范

- **组件文件**: 大驼峰 `ChatMessage.tsx`
- **组件目录**: 大驼峰 `ChatMessage/`
- **组件名**: 大驼峰 `ChatMessage`
- **Hooks**: use开头+小驼峰 `useChat.ts`, `useAuth.ts`
- **工具函数**: 小驼峰 `formatDate.ts`, `parseMessage.ts`
- **常量**: 大写+下划线 `API_BASE_URL`
- **类型/接口**: 大驼峰 `UserType`, `ChatMessageProps`
- **样式文件**: 组件名.module.css `ChatMessage.module.css`
- **测试文件**: 组件名.test.tsx `ChatMessage.test.tsx`

### 项目结构

```
frontend/src/
  components/          # 通用组件
    ui/                # UI基础组件（Button, Input等）
      Button/
        Button.tsx
        Button.module.css
        Button.test.tsx
        index.ts
    layout/            # 布局组件
      Header/
      Sidebar/
      Footer/
    chat/              # 聊天组件
      ChatMessage/
      ChatInput/
      ChatContainer/
  features/            # 功能模块
    auth/              # 认证模块
      components/
      hooks/
      api/
      types/
      index.ts
    chat/              # 聊天模块
      components/
      hooks/
      api/
      types/
      index.ts
    settings/          # 设置模块
  hooks/               # 全局Hooks
    useAuth.ts
    useChat.ts
    useWebSocket.ts
  services/            # API服务层
    api.ts             # API客户端
    chat.ts            # 聊天API
    user.ts            # 用户API
    voice.ts           # 语音API
  store/               # 状态管理
    slices/            # Zustand slices
      authSlice.ts
      chatSlice.ts
    store.ts
  types/               # TypeScript类型定义
    user.ts
    chat.ts
    api.ts
  utils/               # 工具函数
    format.ts
    storage.ts
    validation.ts
  styles/              # 全局样式
    globals.css
    variables.css
    reset.css
  App.tsx              # 应用入口
  main.tsx             # 应用启动
```

### 状态管理规范

**Zustand Store规范**:

```typescript
// src/store/slices/chatSlice.ts
import { create } from 'zustand';
import { devtools, persist } from 'zustand/middleware';
import type { Message, ChatState } from '@/types/chat';

interface ChatStore extends ChatState {
  // Actions
  addMessage: (message: Message) => void;
  clearMessages: () => void;
  setLoading: (loading: boolean) => void;
  setError: (error: string | null) => void;
}

/**
 * 聊天状态管理Store
 * 
 * 使用Zustand管理聊天相关的全局状态。
 */
export const useChatStore = create<ChatStore>()(
  devtools(
    persist(
      (set) => ({
        // State
        messages: [],
        loading: false,
        error: null,
        
        // Actions
        addMessage: (message) =>
          set((state) => ({
            messages: [...state.messages, message],
          })),
        
        clearMessages: () =>
          set({
            messages: [],
            error: null,
          }),
        
        setLoading: (loading) =>
          set({ loading }),
        
        setError: (error) =>
          set({ error }),
      }),
      {
        name: 'chat-storage',
        partialize: (state) => ({
          messages: state.messages,
        }),
      }
    ),
    { name: 'ChatStore' }
  )
);
```

**React Query规范**:

```typescript
// src/hooks/useChat.ts
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { chatApi } from '@/services/chat';
import type { Message, ChatRequest } from '@/types/chat';

/**
 * 聊天Hook
 * 
 * 使用React Query管理聊天相关的服务端状态。
 */
export const useChat = (sessionId: string, personalityId: string) => {
  const queryClient = useQueryClient();
  
  // 获取历史消息
  const { data: messages = [], isLoading } = useQuery({
    queryKey: ['chat', 'messages', sessionId],
    queryFn: () => chatApi.getHistory(sessionId),
    enabled: !!sessionId,
  });
  
  // 发送消息
  const sendMutation = useMutation({
    mutationFn: (request: ChatRequest) => chatApi.send(request),
    onSuccess: (response) => {
      // 更新缓存
      queryClient.setQueryData(
        ['chat', 'messages', sessionId],
        (old: Message[] = []) => [...old, response.message]
      );
    },
  });
  
  const sendMessage = async (content: string) => {
    await sendMutation.mutateAsync({
      messages: [
        ...messages.map((m) => ({
          role: m.role,
          content: m.content,
        })),
        { role: 'user', content },
      ],
      personality_id: personalityId,
      stream: false,
    });
  };
  
  return {
    messages,
    isLoading,
    sendMessage,
    isSending: sendMutation.isPending,
  };
};
```

### API调用规范

**API客户端规范**:

```typescript
// src/services/api.ts
import axios, { AxiosInstance, AxiosRequestConfig, AxiosResponse } from 'axios';

const API_BASE_URL = import.meta.env.VITE_API_BASE_URL || 'http://localhost:8000';

/**
 * API客户端类
 * 
 * 封装Axios，提供统一的API调用接口。
 */
class ApiClient {
  private client: AxiosInstance;

  constructor() {
    this.client = axios.create({
      baseURL: API_BASE_URL,
      timeout: 30000,
      headers: {
        'Content-Type': 'application/json',
      },
    });

    this.setupInterceptors();
  }

  private setupInterceptors() {
    // 请求拦截器
    this.client.interceptors.request.use(
      (config) => {
        const token = localStorage.getItem('access_token');
        if (token) {
          config.headers.Authorization = `Bearer ${token}`;
        }
        return config;
      },
      (error) => Promise.reject(error)
    );

    // 响应拦截器
    this.client.interceptors.response.use(
      (response) => response,
      (error) => {
        if (error.response?.status === 401) {
          // 处理认证失败
          localStorage.removeItem('access_token');
          window.location.href = '/login';
        }
        return Promise.reject(error);
      }
    );
  }

  async get<T>(url: string, config?: AxiosRequestConfig): Promise<T> {
    const response = await this.client.get<T>(url, config);
    return response.data;
  }

  async post<T>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T> {
    const response = await this.client.post<T>(url, data, config);
    return response.data;
  }

  async put<T>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T> {
    const response = await this.client.put<T>(url, data, config);
    return response.data;
  }

  async delete<T>(url: string, config?: AxiosRequestConfig): Promise<T> {
    const response = await this.client.delete<T>(url, config);
    return response.data;
  }
}

export const apiClient = new ApiClient();
```

**API服务规范**:

```typescript
// src/services/chat.ts
import { apiClient } from './api';
import type { Message, ChatRequest, ChatResponse } from '@/types/chat';

/**
 * 聊天API服务
 * 
 * 封装聊天相关的API调用。
 */
export const chatApi = {
  /**
   * 发送聊天消息
   */
  async send(request: ChatRequest): Promise<ChatResponse> {
    return apiClient.post<ChatResponse>('/v1/chat/completions', request);
  },

  /**
   * 获取历史消息
   */
  async getHistory(sessionId: string): Promise<Message[]> {
    return apiClient.get<Message[]>(`/v1/chat/sessions/${sessionId}/messages`);
  },

  /**
   * 流式聊天（SSE）
   */
  async *streamChat(request: ChatRequest): AsyncGenerator<string> {
    const response = await fetch(
      `${import.meta.env.VITE_API_BASE_URL}/v1/chat/stream`,
      {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          Authorization: `Bearer ${localStorage.getItem('access_token')}`,
        },
        body: JSON.stringify(request),
      }
    );

    const reader = response.body?.getReader();
    const decoder = new TextDecoder();

    while (true) {
      const { done, value } = await reader!.read();
      if (done) break;

      const chunk = decoder.decode(value);
      const lines = chunk.split('\n');

      for (const line of lines) {
        if (line.startsWith('data: ')) {
          const data = line.slice(6);
          if (data === '[DONE]') return;
          yield data;
        }
      }
    }
  },
};
```

### Hooks使用规范

```typescript
// ✅ 性能优化
import { useMemo, useCallback } from 'react';

const sortedMessages = useMemo(() => {
  return messages.sort((a, b) => a.timestamp - b.timestamp);
}, [messages]);

const handleClick = useCallback((id: string) => {
  onMessageClick(id);
}, [onMessageClick]);
```

### 样式规范

**CSS Modules规范**:

```css
/* src/components/chat/ChatMessage/ChatMessage.module.css */
.message {
  display: flex;
  gap: 12px;
  padding: 16px;
  margin-bottom: 12px;
  border-radius: 8px;
  transition: background-color 0.2s;
}

.message:hover {
  background-color: var(--hover-bg);
}

.user {
  flex-direction: row-reverse;
  background-color: var(--user-message-bg);
}

.assistant {
  background-color: var(--assistant-message-bg);
}
```

**CSS变量规范**:

```css
/* src/styles/variables.css */
:root {
  /* Colors */
  --primary-color: #3b82f6;
  --secondary-color: #64748b;
  --success-color: #10b981;
  --error-color: #ef4444;
  
  /* Backgrounds */
  --bg-primary: #ffffff;
  --bg-secondary: #f8fafc;
  --hover-bg: #f1f5f9;
  
  /* Text */
  --text-primary: #0f172a;
  --text-secondary: #64748b;
  
  /* Spacing */
  --spacing-xs: 4px;
  --spacing-sm: 8px;
  --spacing-md: 16px;
  --spacing-lg: 24px;
  --spacing-xl: 32px;
  
  /* Border */
  --border-radius: 8px;
  --border-color: #e2e8f0;
}
```

### 性能优化规范

**代码分割**:

```typescript
// 路由懒加载
import { lazy, Suspense } from 'react';
import { BrowserRouter, Routes, Route } from 'react-router-dom';

const Chat = lazy(() => import('./features/chat/Chat'));
const Settings = lazy(() => import('./features/settings/Settings'));

function App() {
  return (
    <BrowserRouter>
      <Suspense fallback={<Loading />}>
        <Routes>
          <Route path="/chat" element={<Chat />} />
          <Route path="/settings" element={<Settings />} />
        </Routes>
      </Suspense>
    </BrowserRouter>
  );
}
```

**虚拟滚动**:

```typescript
import { FixedSizeList } from 'react-window';

function MessageList({ messages }) {
  const Row = ({ index, style }) => (
    <div style={style}>
      <ChatMessage {...messages[index]} />
    </div>
  );

  return (
    <FixedSizeList
      height={600}
      itemCount={messages.length}
      itemSize={100}
      width="100%"
    >
      {Row}
    </FixedSizeList>
  );
}
```

## 数据库规范

### 模型定义
```python
from sqlalchemy import Column, String, DateTime, JSON
from app.models.base import Base

class User(Base):
    """用户表"""
    __tablename__ = "users"
    
    id = Column(String(36), primary_key=True)
    username = Column(String(50), unique=True, nullable=False, index=True)
    email = Column(String(100), unique=True, nullable=False, index=True)
    password_hash = Column(String(255), nullable=False)
    preferences = Column(JSON, default={})
    created_at = Column(DateTime, nullable=False)
    updated_at = Column(DateTime, nullable=False)
```

### 数据库迁移
```bash
# 生成迁移脚本
alembic revision --autogenerate -m "Add user preferences"

# 应用迁移
alembic upgrade head

# 回滚
alembic downgrade -1
```

## 配置管理

### 环境变量
```python
# backend/.env（不提交到Git）
OPENAI_API_KEY=sk-xxx
DATABASE_URL=postgresql://user:pass@localhost/cozychat
REDIS_URL=redis://localhost:6379/0

# 使用Pydantic加载
from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    openai_api_key: str
    database_url: str
    redis_url: str
    
    class Config:
        env_file = ".env"

settings = Settings()
```

### YAML配置
```yaml
# personalities/assistant.yaml
id: assistant_001
name: "AI助手"
description: "通用AI助手"

ai:
  provider: openai
  model: gpt-4
  temperature: 0.7

memory:
  enabled: true
  save_mode: both

tools:
  enabled: true
  allowed_tools:
    - search
    - calculator
```

## API设计规范

### 路由组织
```python
# app/api/v1/chat.py
from fastapi import APIRouter, Depends

router = APIRouter(prefix="/chat", tags=["Chat"])

@router.post("/completions")
async def create_chat_completion(
    request: ChatRequest,
    user: User = Depends(get_current_user)
) -> ChatResponse:
    """创建聊天完成"""
    pass
```

### 请求/响应模型
```python
from pydantic import BaseModel, Field

class ChatRequest(BaseModel):
    """聊天请求"""
    messages: List[Dict[str, str]] = Field(..., description="消息列表")
    personality_id: str = Field(..., description="人格ID")
    stream: bool = Field(default=False, description="是否流式")
    
    class Config:
        json_schema_extra = {
            "example": {
                "messages": [{"role": "user", "content": "你好"}],
                "personality_id": "assistant_001",
                "stream": False
            }
        }
```

## 测试规范

### 单元测试
```python
import pytest
from app.engines.ai.openai_engine import OpenAIEngine

@pytest.fixture
def openai_engine():
    config = {"api_key": "test_key", "model": "gpt-4"}
    return OpenAIEngine(config)

@pytest.mark.asyncio
async def test_chat_completion(openai_engine, mocker):
    """测试聊天完成"""
    mock_response = {"choices": [{"message": {"content": "Hello!"}}]}
    mocker.patch.object(
        openai_engine.client.chat.completions,
        "create",
        return_value=mock_response
    )
    
    result = await openai_engine.chat_completion([{"role": "user", "content": "Hi"}])
    assert result["content"] == "Hello!"
```

### React组件测试
```typescript
import { render, screen } from '@testing-library/react';
import ChatMessage from './ChatMessage';

describe('ChatMessage', () => {
  it('renders user message correctly', () => {
    render(
      <ChatMessage
        role="user"
        content="Hello"
        timestamp={new Date()}
      />
    );
    expect(screen.getByText('Hello')).toBeInTheDocument();
  });
});
```

## 安全规范

### API密钥
- ❌ 绝对不要在代码中硬编码API密钥
- ✅ 使用环境变量管理
- ✅ `.env` 文件添加到 `.gitignore`

### 用户认证
```python
# 使用JWT token
from fastapi import Depends, HTTPException
from fastapi.security import HTTPBearer

security = HTTPBearer()

async def get_current_user(
    credentials = Depends(security)
) -> User:
    """获取当前用户"""
    token = credentials.credentials
    payload = verify_token(token)
    if not payload:
        raise HTTPException(status_code=401, detail="Invalid token")
    return await get_user(payload["user_id"])
```

## 性能优化

### 后端
- 使用异步I/O（asyncio）
- 数据库连接池
- Redis缓存热点数据
- 记忆检索设置超时（0.5秒）

### 前端
- 代码分割（React.lazy）
- 虚拟滚动（长列表）
- 使用 useMemo/useCallback 避免重复计算
- 图片懒加载

## 代码审查清单

提交代码前检查：
- [ ] 代码通过 pre-commit hooks 检查
- [ ] 类型注解完整（Python/TypeScript）
- [ ] 包含必要的测试用例
- [ ] 日志记录关键操作
- [ ] 错误处理完善
- [ ] API变更更新了文档
- [ ] 环境变量添加到 `.env.example`
- [ ] 数据库变更生成了迁移脚本

## 测试规范

### 测试策略

**核心原则**：边开发边测试（Test-Driven Development）

```
开发流程：编写代码 → 编写测试 → 运行测试 → 重构 → 提交
```

### 测试分层

| 测试类型 | 时机 | 覆盖率 |
|---------|------|-------|
| 单元测试 | 编写代码时 | ≥80% |
| 模块测试 | 模块完成后 | ≥70% |
| API测试 | 后端完成后 | 100%核心API |
| 集成测试 | 前后端对接 | ≥60% |
| E2E测试 | 系统完成后 | 核心流程100% |

### Python单元测试

```python
# tests/unit/engines/ai/test_openai_engine.py
import pytest
from unittest.mock import AsyncMock
from app.engines.ai.openai_engine import OpenAIEngine

class TestOpenAIEngine:
    """OpenAI引擎测试"""
    
    @pytest.fixture
    def engine(self):
        """引擎实例"""
        config = {"api_key": "test_key", "model": "gpt-4"}
        return OpenAIEngine(config)
    
    @pytest.mark.asyncio
    async def test_chat_completion_success(self, engine, mocker):
        """测试：聊天完成成功"""
        # Arrange - 准备
        mock_response = {
            "choices": [{"message": {"content": "Hello!"}}]
        }
        mocker.patch.object(
            engine.client.chat.completions,
            "create",
            AsyncMock(return_value=mock_response)
        )
        
        # Act - 执行
        result = await engine.chat_completion([
            {"role": "user", "content": "Hi"}
        ])
        
        # Assert - 断言
        assert result["content"] == "Hello!"
    
    @pytest.mark.asyncio
    async def test_chat_completion_error(self, engine, mocker):
        """测试：API错误处理"""
        mocker.patch.object(
            engine.client.chat.completions,
            "create",
            AsyncMock(side_effect=Exception("API Error"))
        )
        
        with pytest.raises(Exception) as exc_info:
            await engine.chat_completion([{"role": "user", "content": "Hi"}])
        
        assert "API Error" in str(exc_info.value)
```

### React组件测试

```typescript
// src/components/chat/ChatMessage/ChatMessage.test.tsx
import { render, screen, fireEvent } from '@testing-library/react';
import { describe, it, expect, vi } from 'vitest';
import ChatMessage from './ChatMessage';

describe('ChatMessage', () => {
  it('renders user message correctly', () => {
    render(
      <ChatMessage
        role="user"
        content="Hello"
        timestamp={new Date()}
      />
    );
    
    expect(screen.getByText('Hello')).toBeInTheDocument();
  });
  
  it('calls onClick when clicked', () => {
    const handleClick = vi.fn();
    render(
      <ChatMessage
        role="user"
        content="Hello"
        onClick={handleClick}
        timestamp={new Date()}
      />
    );
    
    fireEvent.click(screen.getByTestId('user-message'));
    expect(handleClick).toHaveBeenCalledTimes(1);
  });
});
```

### 测试文件组织

```
backend/tests/
  unit/              # 单元测试
    engines/
      ai/test_openai_engine.py
      memory/test_retriever.py
    core/test_orchestrator.py
  integration/       # 集成测试
    test_chat_flow.py
  api/               # API测试
    test_chat_api.py
  fixtures/
    conftest.py      # pytest配置

frontend/tests/
  components/        # 组件测试
    ChatMessage.test.tsx
  hooks/             # Hook测试
    useChat.test.ts
  integration/       # 集成测试
    chat.test.ts
```

### 测试命名规范

```python
# 格式：test_<功能>_<场景>_<预期结果>
def test_retrieve_memories_with_valid_query_returns_results():
    pass

def test_retrieve_memories_with_timeout_returns_empty():
    pass

def test_authenticate_with_invalid_password_raises_error():
    pass
```

### Mock和Fixture使用

```python
# conftest.py - 共享fixtures
import pytest

@pytest.fixture
def test_db():
    """测试数据库"""
    # 创建内存数据库
    engine = create_engine("sqlite:///:memory:")
    Base.metadata.create_all(engine)
    session = SessionLocal()
    yield session
    session.close()

@pytest.fixture
def test_user(test_db):
    """测试用户"""
    user = User(username="testuser", email="test@example.com")
    test_db.add(user)
    test_db.commit()
    return user

@pytest.fixture
def mock_openai_client(mocker):
    """Mock OpenAI客户端"""
    mock = mocker.Mock()
    mock.chat.completions.create = AsyncMock()
    return mock
```

### API测试

```python
# tests/api/test_chat_api.py
from fastapi.testclient import TestClient
from app.main import app

def test_create_chat_completion_success(client, auth_headers):
    """测试：创建聊天完成"""
    response = client.post(
        "/v1/chat/completions",
        json={
            "messages": [{"role": "user", "content": "你好"}],
            "personality_id": "assistant_001"
        },
        headers=auth_headers
    )
    
    assert response.status_code == 200
    data = response.json()
    assert "content" in data
    assert data["role"] == "assistant"

def test_create_chat_completion_unauthorized(client):
    """测试：未授权访问"""
    response = client.post("/v1/chat/completions", json={...})
    assert response.status_code == 401
```

### 测试覆盖率要求

```
核心模块（AI引擎、记忆管理）: ≥ 85%
业务逻辑（用户管理、工具系统）: ≥ 80%
API接口: ≥ 75%
工具函数: ≥ 90%
UI组件: ≥ 60%
```

### 运行测试

```bash
# Python测试
cd backend
pytest tests/ -v --cov=app --cov-report=html

# 运行特定测试
pytest tests/unit/engines/ai/ -v

# React测试
cd frontend
npm run test
npm run test:coverage

# E2E测试
npx playwright test
```

### AAA测试模式

```python
def test_example():
    # Arrange - 准备测试数据和环境
    user = create_test_user()
    
    # Act - 执行被测试的操作
    result = authenticate_user(user.username, "password")
    
    # Assert - 验证结果
    assert result.is_authenticated
    assert result.token is not None
```

### 测试最佳实践

1. **每个功能必须有测试** - 编写代码时同时编写测试
2. **测试应该独立** - 测试之间不应相互依赖
3. **测试应该快速** - 单元测试应在毫秒级完成
4. **使用有意义的断言** - 断言失败时能快速定位问题
5. **Mock外部依赖** - 数据库、API、文件系统等
6. **测试边界条件** - 空值、极大值、错误输入等

## 开发流程管控

**核心原则：文档驱动开发（Documentation-Driven Development）**

### 开发前必做

```
开始任何开发前，必须先阅读相关文档：

后端开发：
☑ docs/02-后端架构设计.md - 理解模块在架构中的位置
☑ docs/06-开发规范.md - 遵循编码规范
☑ docs/07-测试规范.md - 了解测试要求

前端开发：
☑ docs/03-前端架构设计.md - 理解组件设计
☑ docs/17-前端开发规范.md - 完整前端开发规范（ChatUI + Ant Design）
☑ docs/14-ChatUI实施指南.md - ChatUI使用指南
☑ docs/15-ChatUI-Drawer实现方案.md - Drawer组件实现方案
☑ docs/06-开发规范.md (React部分) - 遵循React规范
☑ docs/07-测试规范.md (前端部分) - 组件测试要求

API开发：
☑ docs/04-API接口设计.md - 遵循接口规范

数据库变更：
☑ docs/05-数据库设计.md - 理解数据模型
```

### 开发过程中

**每写一个类/函数都要对照文档检查：**

```python
# 检查清单：
# [ ] 命名符合规范（参考：06-开发规范.md 2.3节）
# [ ] 类型注解完整（参考：06-开发规范.md 2.4节）
# [ ] 文档字符串完整（参考：06-开发规范.md 2.1.2节）
# [ ] 错误处理完善（参考：06-开发规范.md 2.5节）
# [ ] 日志记录充分（参考：06-开发规范.md 2.7节）
# [ ] 实现与设计一致（参考：架构设计文档）

class MemoryRetriever:
    """记忆检索器
    
    参考文档: docs/02-后端架构设计-续.md (2.3节)
    """
    pass
```

### 功能完成后必做

**完成检查清单（全部勾选才能提交）：**

```markdown
代码质量：
[ ] 所有测试通过（pytest tests/ -v）
[ ] 代码覆盖率达标（≥85% for 核心模块）
[ ] Pre-commit hooks通过
[ ] 对照架构文档验证实现

功能验证：
[ ] 功能与需求描述一致
[ ] 与设计文档完全匹配
[ ] 性能指标达标
[ ] 错误处理完整

测试覆盖：
[ ] 单元测试完整
[ ] 集成测试通过（如需要）
[ ] API测试通过（如有API）
[ ] 边界条件测试

文档同步：
[ ] 代码注释完整
[ ] API文档更新（如有变更）
[ ] 架构文档更新（如有变更）
[ ] .env.example更新（如有新环境变量）
[ ] 数据库迁移脚本（如有schema变更）
```

### 提交代码前

**强制性文档验证：**

```python
# 提交前必须回答以下问题：

1. 我的实现与哪个文档的哪一节相关？
   答：docs/02-后端架构设计-续.md (2.3节)

2. 我的实现是否完全符合文档描述？
   答：是 / 否（如否，是否已更新文档？）

3. 如果与文档有偏差，原因是什么？
   答：（说明原因，并确认已更新文档）

4. 文档是否需要更新？
   答：是 / 否
   
5. 如需更新，哪些文档需要更新？
   答：[ ] 架构文档 [ ] API文档 [ ] 数据库文档 [ ] README
```

### Commit Message要求

```bash
# 必须包含参考文档
feat(memory): implement memory retriever with cache

实现记忆检索器，包含：
- 向量数据库检索
- TTL缓存（5分钟）
- 超时控制（0.5秒）

参考文档：docs/02-后端架构设计-续.md (2.3节)
测试覆盖率：88%

Closes #123
```

### 代码审查要点

```markdown
审查时必须检查：

[ ] 代码实现与设计文档一致
[ ] 遵循开发规范（06-开发规范.md）
[ ] 测试符合测试规范（07-测试规范.md）
[ ] 文档已同步更新
[ ] Commit message包含文档引用
```

### 模块完成标准

一个模块被认为"完成"必须满足：

```markdown
1. 功能实现 ✓
   [ ] 核心功能完整
   [ ] 实现与设计文档100%一致

2. 测试完成 ✓
   [ ] 单元测试覆盖率≥85%
   [ ] 所有测试通过

3. 文档完成 ✓
   [ ] 架构文档更新
   [ ] API文档更新（如有API）
   [ ] 代码注释完整

4. 验证通过 ✓
   [ ] 对照文档验证通过
   [ ] 代码审查通过
   [ ] QA测试通过
```

### 质量门禁

**提交代码必须通过：**

```
✓ 所有测试通过（100%）
✓ 代码覆盖率≥80%
✓ Pre-commit hooks通过
✓ 对照设计文档验证
✓ 代码审查Approve
✓ 文档同步完成
```

### 文档更新触发条件

以下情况**必须**更新文档：

```markdown
架构变更 → 更新 02-后端架构设计.md 或 03-前端架构设计.md
API变更 → 更新 04-API接口设计.md
数据库变更 → 更新 05-数据库设计.md
环境变量新增 → 更新 .env.example 和 README.md
配置变更 → 更新相关配置文档
```

### AI助手使用要求

**在使用AI助手（如Cursor）时：**

1. **明确告知要开发的功能** - 说明功能在架构中的位置
2. **指定参考文档** - "参考 docs/02-后端架构设计-续.md (2.3节)"
3. **要求对照验证** - "请对照文档验证实现是否正确"
4. **同步更新文档** - "如有偏差，请更新相关文档"

示例对话：
```
User: "帮我实现记忆检索器，参考 docs/02-后端架构设计-续.md 
      的2.3节，要完全符合文档描述"

AI: （生成代码后）"已实现记忆检索器，包含：
    - ✓ TTL缓存机制（符合文档）
    - ✓ 超时控制0.5秒（符合文档）
    - ✓ 区分用户/AI记忆（符合文档）
    代码完全符合架构设计文档的描述。"
```

## 特殊注意事项

### 人格系统
- 人格配置使用YAML文件（`personalities/`目录）
- 人格ID格式：`{name}_{version}`（如 `assistant_001`）
- 修改人格配置后需要重启服务或热重载

### 记忆管理
- 区分用户记忆和AI记忆
- 使用异步保存，不阻塞主流程
- 设置TTL缓存（5分钟，100条）
- 检索超时控制（0.5秒）

### 工具系统
- 内置工具放在 `app/engines/tools/builtin/`
- MCP工具自动发现和注册
- 工具执行设置超时保护

### 语音功能
- STT/TTS/RealTime三大引擎分离
- 支持多提供商（OpenAI/腾讯/自定义）
- 使用工厂模式创建引擎实例

## 文档参考

详细规范请参考：
- `docs/06-开发规范.md` - 完整开发规范
- `docs/17-前端开发规范.md` - 完整前端开发规范（ChatUI + Ant Design）
- `docs/14-ChatUI实施指南.md` - ChatUI使用指南
- `docs/15-ChatUI-Drawer实现方案.md` - Drawer组件实现方案
- `docs/07-测试规范.md` - 完整测试规范和最佳实践
- `docs/08-开发流程管控.md` - 开发流程管控和文档驱动开发
- `docs/02-后端架构设计.md` - 后端架构设计
- `docs/03-前端架构设计.md` - 前端架构设计
- `docs/04-API接口设计.md` - API接口规范
- `docs/05-数据库设计.md` - 数据库设计

---

**重要提醒**:

1. **文档驱动开发**: 开发前必须先阅读相关设计文档，开发过程中对照文档实现，完成后对照文档验证
2. **严格遵循规范**: 在生成代码时，请严格遵循以上规范，如果对某个规范不确定，请先查阅相关文档
3. **文档同步**: 代码变更后，如有偏差或新增功能，必须同步更新相关文档
4. **质量把关**: 每次提交代码前，必须对照检查清单完成所有验证项

**详细流程请参考**: `docs/08-开发流程管控.md`

