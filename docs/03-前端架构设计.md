# CozyChat 前端架构设计

## 1. 技术栈

### 1.1 核心框架

```yaml
UI框架: React 18+
类型系统: TypeScript 5+
构建工具: Vite 5+
包管理器: pnpm / yarn
```

### 1.2 UI组件库

```yaml
AI聊天组件:
  - @chatui/core: 首选（专为聊天设计，功能完整，企业级成熟度）
  - @assistant-ui/react: 备选（支持消息分组、工具调用、Headless UI）
  - @ant-design/x: 备选（企业级成熟度，Ant Design 生态）
  - @langui/react: 备选（快速集成，基于 Tailwind CSS）

通用UI组件:
  - antd: 成熟的React组件库（布局、表单、反馈等）
  - shadcn/ui: 基于Radix UI的组件集合（可选）

样式方案:
  - TailwindCSS: 原子化CSS框架
  - CSS Modules: 作为备选

图标库:
  - lucide-react: 现代化图标库
  - @iconify/react: 统一图标接口
```

### 1.3 状态管理

```yaml
全局状态:
  - Zustand: 轻量级状态管理
  - 或 Jotai: 原子化状态管理

服务端状态:
  - TanStack Query (React Query): 
    * 数据获取
    * 缓存管理
    * 乐观更新

表单状态:
  - React Hook Form: 表单管理
  - Zod: 数据验证
```

### 1.4 路由和导航

```yaml
路由: React Router v6+
- 嵌套路由
- 路由守卫
- 懒加载

导航:
- 面包屑导航
- 侧边栏导航
- 移动端抽屉导航
```

### 1.5 实时通信

```yaml
WebSocket:
  - 原生WebSocket API
  - 自动重连机制

SSE (Server-Sent Events):
  - EventSource API
  - 流式数据处理

HTTP:
  - Axios / Fetch API
  - 请求拦截器
  - 响应拦截器
```

### 1.6 工具库

```yaml
日期处理: date-fns
音频处理: Web Audio API + Recorder.js
文件处理: file-saver
Markdown渲染: react-markdown + remark-gfm
代码高亮: prismjs / highlight.js
富文本编辑: TipTap (可选)
```

## 2. 项目结构

```
frontend/
├── public/
│   ├── index.html
│   ├── favicon.ico
│   └── assets/
│       └── images/
│
├── src/
│   ├── main.tsx                  # 应用入口
│   ├── App.tsx                   # 根组件
│   │
│   ├── components/               # 通用组件
│   │   ├── ui/                   # UI基础组件
│   │   │   ├── Button.tsx
│   │   │   ├── Input.tsx
│   │   │   ├── Modal.tsx
│   │   │   ├── Avatar.tsx
│   │   │   └── ...
│   │   │
│   │   ├── chat/                 # 聊天相关组件
│   │   │   ├── ChatContainer.tsx        # 聊天容器
│   │   │   ├── MessageList.tsx          # 消息列表
│   │   │   ├── MessageItem.tsx          # 单条消息
│   │   │   ├── InputArea.tsx            # 输入区域
│   │   │   ├── VoiceRecorder.tsx        # 语音录制
│   │   │   ├── VoicePlayer.tsx          # 语音播放
│   │   │   └── TypingIndicator.tsx      # 输入中指示器
│   │   │
│   │   ├── session/              # 会话相关组件
│   │   │   ├── SessionList.tsx           # 会话列表
│   │   │   ├── SessionItem.tsx           # 会话项
│   │   │   └── SessionSearch.tsx         # 会话搜索
│   │   │
│   │   ├── personality/          # 人格相关组件
│   │   │   ├── PersonalitySelector.tsx  # 人格选择器
│   │   │   ├── PersonalityCard.tsx      # 人格卡片
│   │   │   └── PersonalityEditor.tsx    # 人格编辑器
│   │   │
│   │   ├── user/                 # 用户相关组件
│   │   │   ├── UserProfile.tsx           # 用户资料
│   │   │   ├── UserSettings.tsx          # 用户设置
│   │   │   └── UserAvatar.tsx            # 用户头像
│   │   │
│   │   ├── layout/               # 布局组件
│   │   │   ├── Header.tsx
│   │   │   ├── Sidebar.tsx
│   │   │   ├── Footer.tsx
│   │   │   └── MobileNav.tsx
│   │   │
│   │   └── common/               # 通用组件
│   │       ├── Loading.tsx
│   │       ├── ErrorBoundary.tsx
│   │       ├── Toast.tsx
│   │       └── ConfirmDialog.tsx
│   │
│   ├── pages/                    # 页面组件
│   │   ├── auth/
│   │   │   ├── LoginPage.tsx
│   │   │   ├── RegisterPage.tsx
│   │   │   └── ForgotPasswordPage.tsx
│   │   │
│   │   ├── chat/
│   │   │   ├── ChatPage.tsx              # 主聊天页面
│   │   │   └── SessionDetailPage.tsx     # 会话详情
│   │   │
│   │   ├── personalities/
│   │   │   ├── PersonalitiesPage.tsx     # 人格列表
│   │   │   ├── PersonalityDetailPage.tsx # 人格详情
│   │   │   └── CreatePersonalityPage.tsx # 创建人格
│   │   │
│   │   ├── user/
│   │   │   ├── ProfilePage.tsx           # 个人资料
│   │   │   ├── SettingsPage.tsx          # 设置
│   │   │   └── UsageStatsPage.tsx        # 使用统计
│   │   │
│   │   └── NotFoundPage.tsx
│   │
│   ├── hooks/                    # 自定义Hooks
│   │   ├── useAuth.ts                    # 认证Hook
│   │   ├── useChat.ts                    # 聊天Hook
│   │   ├── useWebSocket.ts               # WebSocket Hook
│   │   ├── useSSE.ts                     # SSE Hook
│   │   ├── useVoiceRecorder.ts           # 语音录制Hook
│   │   ├── useVoicePlayer.ts             # 语音播放Hook
│   │   ├── useMediaQuery.ts              # 响应式Hook
│   │   └── useLocalStorage.ts            # 本地存储Hook
│   │
│   ├── store/                    # 状态管理
│   │   ├── authStore.ts                  # 认证状态
│   │   ├── chatStore.ts                  # 聊天状态
│   │   ├── uiStore.ts                    # UI状态
│   │   └── settingsStore.ts              # 设置状态
│   │
│   ├── services/                 # API服务
│   │   ├── api/
│   │   │   ├── client.ts                 # API客户端配置
│   │   │   ├── auth.ts                   # 认证API
│   │   │   ├── chat.ts                   # 聊天API
│   │   │   ├── personality.ts            # 人格API
│   │   │   ├── session.ts                # 会话API
│   │   │   ├── user.ts                   # 用户API
│   │   │   ├── memory.ts                 # 记忆API
│   │   │   └── tool.ts                   # 工具API
│   │   │
│   │   ├── websocket/
│   │   │   ├── WebSocketService.ts       # WebSocket服务
│   │   │   └── MessageHandler.ts         # 消息处理器
│   │   │
│   │   └── audio/
│   │       ├── AudioRecorder.ts          # 音频录制
│   │       ├── AudioPlayer.ts            # 音频播放
│   │       └── AudioProcessor.ts         # 音频处理
│   │
│   ├── types/                    # TypeScript类型定义
│   │   ├── api.ts
│   │   ├── chat.ts
│   │   ├── user.ts
│   │   ├── personality.ts
│   │   └── index.ts
│   │
│   ├── utils/                    # 工具函数
│   │   ├── format.ts                     # 格式化工具
│   │   ├── validation.ts                 # 验证工具
│   │   ├── storage.ts                    # 存储工具
│   │   ├── audio.ts                      # 音频工具
│   │   └── constants.ts                  # 常量定义
│   │
│   ├── styles/                   # 全局样式
│   │   ├── globals.css
│   │   ├── variables.css
│   │   └── themes/
│   │       ├── light.css
│   │       └── dark.css
│   │
│   └── config/                   # 配置文件
│       ├── env.ts                        # 环境变量
│       └── routes.ts                     # 路由配置
│
├── .env.example
├── .eslintrc.cjs
├── .prettierrc
├── tsconfig.json
├── vite.config.ts
├── tailwind.config.js
└── package.json
```

## 3. 核心功能模块

### 3.1 认证系统

#### AuthContext和Hook

```typescript
// src/hooks/useAuth.ts
import { create } from 'zustand';
import { persist } from 'zustand/middleware';

interface User {
  id: string;
  username: string;
  email: string;
  role: string;
  preferences: UserPreferences;
}

interface AuthState {
  user: User | null;
  token: string | null;
  isAuthenticated: boolean;
  isLoading: boolean;
  
  login: (username: string, password: string) => Promise<void>;
  logout: () => void;
  register: (data: RegisterData) => Promise<void>;
  refreshToken: () => Promise<void>;
  updatePreferences: (prefs: Partial<UserPreferences>) => Promise<void>;
}

export const useAuthStore = create<AuthState>()(
  persist(
    (set, get) => ({
      user: null,
      token: null,
      isAuthenticated: false,
      isLoading: false,
      
      login: async (username, password) => {
        set({ isLoading: true });
        try {
          const response = await authApi.login({ username, password });
          set({
            user: response.user,
            token: response.access_token,
            isAuthenticated: true,
            isLoading: false
          });
        } catch (error) {
          set({ isLoading: false });
          throw error;
        }
      },
      
      logout: () => {
        set({
          user: null,
          token: null,
          isAuthenticated: false
        });
      },
      
      // ... 其他方法
    }),
    {
      name: 'auth-storage',
      partialize: (state) => ({
        user: state.user,
        token: state.token,
        isAuthenticated: state.isAuthenticated
      })
    }
  )
);
```

#### 路由守卫

```typescript
// src/components/auth/ProtectedRoute.tsx
import { Navigate, useLocation } from 'react-router-dom';
import { useAuthStore } from '@/hooks/useAuth';

interface ProtectedRouteProps {
  children: React.ReactNode;
  requiredRole?: string;
}

export const ProtectedRoute: React.FC<ProtectedRouteProps> = ({ 
  children, 
  requiredRole 
}) => {
  const { isAuthenticated, user } = useAuthStore();
  const location = useLocation();
  
  if (!isAuthenticated) {
    return <Navigate to="/login" state={{ from: location }} replace />;
  }
  
  if (requiredRole && user?.role !== requiredRole) {
    return <Navigate to="/forbidden" replace />;
  }
  
  return <>{children}</>;
};
```

### 3.2 聊天系统

#### Chat Hook

```typescript
// src/hooks/useChat.ts
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { chatApi } from '@/services/api/chat';

export const useChat = (sessionId: string) => {
  const queryClient = useQueryClient();
  
  // 获取消息列表
  const { data: messages, isLoading } = useQuery({
    queryKey: ['messages', sessionId],
    queryFn: () => chatApi.getMessages(sessionId),
    enabled: !!sessionId
  });
  
  // 发送消息（流式）
  const sendStreamMessage = async (content: string, options?: ChatOptions) => {
    const response = await chatApi.streamChat({
      messages: [...messages, { role: 'user', content }],
      session_id: sessionId,
      personality_id: options?.personalityId,
      stream: true
    });
    
    return response; // SSE流
  };
  
  // 发送消息（非流式）
  const sendMessage = useMutation({
    mutationFn: (data: { content: string; options?: ChatOptions }) =>
      chatApi.chat({
        messages: [...messages, { role: 'user', content: data.content }],
        session_id: sessionId,
        ...data.options
      }),
    onSuccess: () => {
      queryClient.invalidateQueries(['messages', sessionId]);
    }
  });
  
  // 重新生成回复
  const regenerate = useMutation({
    mutationFn: () => chatApi.regenerate(sessionId),
    onSuccess: () => {
      queryClient.invalidateQueries(['messages', sessionId]);
    }
  });
  
  return {
    messages,
    isLoading,
    sendMessage: sendMessage.mutate,
    sendStreamMessage,
    regenerate: regenerate.mutate,
    isRegenerating: regenerate.isLoading
  };
};
```

#### SSE流式处理

```typescript
// src/hooks/useSSE.ts
import { useState, useCallback, useRef } from 'react';

interface SSEOptions {
  onMessage?: (data: any) => void;
  onComplete?: () => void;
  onError?: (error: Error) => void;
}

export const useSSE = () => {
  const [isStreaming, setIsStreaming] = useState(false);
  const [streamingContent, setStreamingContent] = useState('');
  const eventSourceRef = useRef<EventSource | null>(null);
  
  const startStream = useCallback(
    async (url: string, options: SSEOptions = {}) => {
      setIsStreaming(true);
      setStreamingContent('');
      
      try {
        const eventSource = new EventSource(url);
        eventSourceRef.current = eventSource;
        
        eventSource.onmessage = (event) => {
          if (event.data === '[DONE]') {
            eventSource.close();
            setIsStreaming(false);
            options.onComplete?.();
            return;
          }
          
          try {
            const data = JSON.parse(event.data);
            const content = data.choices[0]?.delta?.content || '';
            
            setStreamingContent(prev => prev + content);
            options.onMessage?.(data);
          } catch (error) {
            console.error('Failed to parse SSE data:', error);
          }
        };
        
        eventSource.onerror = (error) => {
          console.error('SSE error:', error);
          eventSource.close();
          setIsStreaming(false);
          options.onError?.(new Error('SSE connection error'));
        };
      } catch (error) {
        setIsStreaming(false);
        options.onError?.(error as Error);
      }
    },
    []
  );
  
  const stopStream = useCallback(() => {
    if (eventSourceRef.current) {
      eventSourceRef.current.close();
      eventSourceRef.current = null;
      setIsStreaming(false);
    }
  }, []);
  
  return {
    isStreaming,
    streamingContent,
    startStream,
    stopStream
  };
};
```

#### ChatContainer组件

```typescript
// src/components/chat/ChatContainer.tsx
import { useState } from 'react';
import { MessageList } from './MessageList';
import { InputArea } from './InputArea';
import { useChat } from '@/hooks/useChat';
import { useSSE } from '@/hooks/useSSE';

interface ChatContainerProps {
  sessionId: string;
  personalityId: string;
}

export const ChatContainer: React.FC<ChatContainerProps> = ({
  sessionId,
  personalityId
}) => {
  const { messages, sendStreamMessage } = useChat(sessionId);
  const { isStreaming, streamingContent, startStream, stopStream } = useSSE();
  const [optimisticMessages, setOptimisticMessages] = useState<Message[]>([]);
  
  const handleSend = async (content: string) => {
    // 乐观更新：立即显示用户消息
    const userMessage = {
      id: `temp-${Date.now()}`,
      role: 'user',
      content,
      created_at: new Date().toISOString()
    };
    setOptimisticMessages(prev => [...prev, userMessage]);
    
    // 开始流式响应
    const stream = await sendStreamMessage(content, { personalityId });
    
    // 处理SSE流
    await startStream(stream.url, {
      onMessage: (data) => {
        // 实时更新AI回复
      },
      onComplete: () => {
        // 清除乐观更新
        setOptimisticMessages([]);
      },
      onError: (error) => {
        console.error('Stream error:', error);
        setOptimisticMessages([]);
      }
    });
  };
  
  const allMessages = [...(messages || []), ...optimisticMessages];
  
  return (
    <div className="flex flex-col h-full">
      <MessageList 
        messages={allMessages}
        streamingContent={isStreaming ? streamingContent : undefined}
      />
      <InputArea 
        onSend={handleSend}
        isLoading={isStreaming}
        onStop={stopStream}
      />
    </div>
  );
};
```

### 3.3 语音功能

#### 语音录制Hook

```typescript
// src/hooks/useVoiceRecorder.ts
import { useState, useRef, useCallback } from 'react';

export const useVoiceRecorder = () => {
  const [isRecording, setIsRecording] = useState(false);
  const [audioBlob, setAudioBlob] = useState<Blob | null>(null);
  const mediaRecorderRef = useRef<MediaRecorder | null>(null);
  const chunksRef = useRef<Blob[]>([]);
  
  const startRecording = useCallback(async () => {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      const mediaRecorder = new MediaRecorder(stream);
      mediaRecorderRef.current = mediaRecorder;
      chunksRef.current = [];
      
      mediaRecorder.ondataavailable = (event) => {
        if (event.data.size > 0) {
          chunksRef.current.push(event.data);
        }
      };
      
      mediaRecorder.onstop = () => {
        const blob = new Blob(chunksRef.current, { type: 'audio/webm' });
        setAudioBlob(blob);
        stream.getTracks().forEach(track => track.stop());
      };
      
      mediaRecorder.start();
      setIsRecording(true);
    } catch (error) {
      console.error('Failed to start recording:', error);
      throw error;
    }
  }, []);
  
  const stopRecording = useCallback(() => {
    if (mediaRecorderRef.current && isRecording) {
      mediaRecorderRef.current.stop();
      setIsRecording(false);
    }
  }, [isRecording]);
  
  const clearAudio = useCallback(() => {
    setAudioBlob(null);
    chunksRef.current = [];
  }, []);
  
  return {
    isRecording,
    audioBlob,
    startRecording,
    stopRecording,
    clearAudio
  };
};
```

### 3.4 响应式设计

#### 移动端适配Hook

```typescript
// src/hooks/useMediaQuery.ts
import { useState, useEffect } from 'react';

export const useMediaQuery = (query: string): boolean => {
  const [matches, setMatches] = useState(false);
  
  useEffect(() => {
    const media = window.matchMedia(query);
    setMatches(media.matches);
    
    const listener = (event: MediaQueryListEvent) => {
      setMatches(event.matches);
    };
    
    media.addEventListener('change', listener);
    return () => media.removeEventListener('change', listener);
  }, [query]);
  
  return matches;
};

// 预定义的断点
export const useBreakpoint = () => {
  const isMobile = useMediaQuery('(max-width: 768px)');
  const isTablet = useMediaQuery('(min-width: 769px) and (max-width: 1024px)');
  const isDesktop = useMediaQuery('(min-width: 1025px)');
  
  return { isMobile, isTablet, isDesktop };
};
```

#### 响应式布局组件

```typescript
// src/components/layout/ResponsiveLayout.tsx
import { useBreakpoint } from '@/hooks/useMediaQuery';
import { MobileNav } from './MobileNav';
import { Sidebar } from './Sidebar';

export const ResponsiveLayout: React.FC<{ children: React.ReactNode }> = ({ 
  children 
}) => {
  const { isMobile } = useBreakpoint();
  
  if (isMobile) {
    return (
      <div className="flex flex-col h-screen">
        <MobileNav />
        <main className="flex-1 overflow-auto">
          {children}
        </main>
      </div>
    );
  }
  
  return (
    <div className="flex h-screen">
      <Sidebar />
      <main className="flex-1 overflow-auto">
        {children}
      </main>
    </div>
  );
};
```

## 4. 主题和样式

### 4.1 主题配置

```typescript
// src/config/theme.ts
export const theme = {
  colors: {
    primary: {
      50: '#f0f9ff',
      100: '#e0f2fe',
      500: '#0ea5e9',
      600: '#0284c7',
      700: '#0369a1',
    },
    // ... 其他颜色
  },
  spacing: {
    xs: '0.25rem',
    sm: '0.5rem',
    md: '1rem',
    lg: '1.5rem',
    xl: '2rem',
  },
  borderRadius: {
    sm: '0.25rem',
    md: '0.5rem',
    lg: '1rem',
    full: '9999px',
  }
};
```

### 4.2 Tailwind配置

```javascript
// tailwind.config.js
module.exports = {
  content: ['./src/**/*.{ts,tsx}'],
  theme: {
    extend: {
      colors: {
        primary: {
          DEFAULT: '#0ea5e9',
          // ...
        }
      }
    }
  },
  plugins: [
    require('@tailwindcss/forms'),
    require('@tailwindcss/typography'),
  ]
};
```

## 5. 性能优化

### 5.1 代码分割

```typescript
// src/App.tsx
import { lazy, Suspense } from 'react';
import { Routes, Route } from 'react-router-dom';
import { Loading } from '@/components/common/Loading';

// 懒加载页面组件
const ChatPage = lazy(() => import('@/pages/chat/ChatPage'));
const PersonalitiesPage = lazy(() => import('@/pages/personalities/PersonalitiesPage'));

export const App = () => (
  <Suspense fallback={<Loading />}>
    <Routes>
      <Route path="/chat" element={<ChatPage />} />
      <Route path="/personalities" element={<PersonalitiesPage />} />
    </Routes>
  </Suspense>
);
```

### 5.2 虚拟列表

```typescript
// src/components/chat/MessageList.tsx
import { useVirtualizer } from '@tanstack/react-virtual';
import { useRef } from 'react';

export const MessageList: React.FC<{ messages: Message[] }> = ({ messages }) => {
  const parentRef = useRef<HTMLDivElement>(null);
  
  const virtualizer = useVirtualizer({
    count: messages.length,
    getScrollElement: () => parentRef.current,
    estimateSize: () => 100,
    overscan: 5
  });
  
  return (
    <div ref={parentRef} className="h-full overflow-auto">
      <div
        style={{
          height: `${virtualizer.getTotalSize()}px`,
          position: 'relative'
        }}
      >
        {virtualizer.getVirtualItems().map(virtualItem => (
          <div
            key={virtualItem.key}
            style={{
              position: 'absolute',
              top: 0,
              left: 0,
              width: '100%',
              transform: `translateY(${virtualItem.start}px)`
            }}
          >
            <MessageItem message={messages[virtualItem.index]} />
          </div>
        ))}
      </div>
    </div>
  );
};
```

---

**文档版本**: v1.0  
**最后更新**: 2025-11-06

