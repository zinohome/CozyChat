# 07-测试规范

## 目录

- [1. 测试策略](#1-测试策略)
- [2. 测试金字塔](#2-测试金字塔)
- [3. 后端测试规范](#3-后端测试规范)
- [4. 前端测试规范](#4-前端测试规范)
- [5. API测试规范](#5-api测试规范)
- [6. 集成测试规范](#6-集成测试规范)
- [7. E2E测试规范](#7-e2e测试规范)
- [8. 测试数据管理](#8-测试数据管理)
- [9. 性能测试](#9-性能测试)
- [10. 测试工具和环境](#10-测试工具和环境)
- [11. CI/CD集成](#11-cicd集成)

---

## 1. 测试策略

### 1.1 测试理念

**核心原则**：边开发边测试（Test-Driven Development）

```
开发流程：
1. 编写功能代码 → 2. 编写单元测试 → 3. 运行测试 → 4. 重构优化 → 5. 提交代码
         ↑                                                                    ↓
         └──────────────────────────── 循环迭代 ───────────────────────────┘
```

### 1.2 测试分层

| 测试类型 | 时机 | 范围 | 覆盖率要求 | 执行频率 |
|---------|------|------|-----------|---------|
| **单元测试** | 编写代码时 | 单个函数/类 | ≥80% | 每次提交 |
| **模块测试** | 模块完成后 | 模块内多个类 | ≥70% | 功能完成 |
| **API测试** | 后端完成后 | API接口 | 100%核心API | 每次部署 |
| **集成测试** | 前后端对接 | 跨模块交互 | ≥60% | 每日构建 |
| **E2E测试** | 系统完成后 | 完整业务流程 | 核心流程100% | 发版前 |

### 1.3 测试覆盖率目标

```
CozyChat测试覆盖率要求：
├─ 核心模块（AI引擎、记忆管理）: ≥ 85%
├─ 业务逻辑（用户管理、工具系统）: ≥ 80%
├─ API接口: ≥ 75%
├─ 工具函数: ≥ 90%
└─ UI组件: ≥ 60%
```

---

## 2. 测试金字塔

```
            ╱╲
           ╱E2E╲          数量少、成本高、速度慢
          ╱────╲          5%
         ╱      ╲
        ╱ 集成测试 ╲       中等数量、中等成本
       ╱──────────╲       15%
      ╱            ╲
     ╱   API测试    ╲     较多数量、较低成本
    ╱──────────────╲     20%
   ╱                ╲
  ╱    单元测试       ╲   大量、低成本、快速
 ╱────────────────────╲  60%
```

### 2.1 金字塔解读

1. **单元测试（60%）**
   - 最多数量
   - 执行最快
   - 反馈最及时
   - 成本最低

2. **API测试（20%）**
   - 测试接口功能
   - 验证业务逻辑
   - 中等执行速度

3. **集成测试（15%）**
   - 测试模块交互
   - 验证数据流
   - 较慢执行速度

4. **E2E测试（5%）**
   - 测试完整流程
   - 模拟真实用户
   - 执行最慢
   - 成本最高

---

## 3. 后端测试规范

### 3.1 单元测试规范

#### 3.1.1 测试文件组织

```
backend/
  tests/
    unit/                           # 单元测试
      engines/
        ai/
          test_openai_engine.py     # 对应 app/engines/ai/openai_engine.py
          test_ollama_engine.py
        memory/
          test_retriever.py
          test_saver.py
        tools/
          test_manager.py
          test_registry.py
      core/
        test_orchestrator.py
        personality/
          test_manager.py
          test_loader.py
      utils/
        test_logger.py
        test_cache.py
    
    integration/                    # 集成测试
      test_chat_flow.py
      test_memory_flow.py
      test_tool_calling.py
    
    api/                            # API测试
      test_chat_api.py
      test_user_api.py
      test_personality_api.py
    
    fixtures/                       # 测试固件
      conftest.py                   # pytest配置和共享fixtures
      factories.py                  # 测试数据工厂
      mocks.py                      # Mock对象
```

#### 3.1.2 测试命名规范

```python
# 测试文件命名：test_<模块名>.py
# 测试类命名：Test<类名>
# 测试函数命名：test_<功能描述>_<场景>_<预期结果>

class TestMemoryRetriever:
    """记忆检索器测试类"""
    
    def test_retrieve_memories_with_valid_query_returns_results(self):
        """测试：使用有效查询检索记忆，应返回结果"""
        pass
    
    def test_retrieve_memories_with_timeout_returns_empty(self):
        """测试：检索超时，应返回空结果"""
        pass
    
    def test_retrieve_memories_with_invalid_type_raises_error(self):
        """测试：使用无效类型，应抛出ValueError"""
        pass
```

#### 3.1.3 单元测试示例

**测试AI引擎**：

```python
# tests/unit/engines/ai/test_openai_engine.py
import pytest
from unittest.mock import AsyncMock, MagicMock
from app.engines.ai.openai_engine import OpenAIEngine
from app.utils.exceptions import AIEngineError

class TestOpenAIEngine:
    """OpenAI引擎测试"""
    
    @pytest.fixture
    def engine_config(self):
        """引擎配置fixture"""
        return {
            "api_key": "test_key",
            "model": "gpt-4",
            "temperature": 0.7,
            "max_tokens": 2000
        }
    
    @pytest.fixture
    def openai_engine(self, engine_config):
        """OpenAI引擎实例fixture"""
        return OpenAIEngine(engine_config)
    
    @pytest.mark.asyncio
    async def test_chat_completion_success(self, openai_engine, mocker):
        """测试：聊天完成成功"""
        # Arrange
        mock_response = {
            "choices": [{
                "message": {
                    "role": "assistant",
                    "content": "Hello! How can I help you?"
                }
            }],
            "usage": {
                "total_tokens": 50
            }
        }
        
        mock_create = AsyncMock(return_value=mock_response)
        mocker.patch.object(
            openai_engine.client.chat.completions,
            "create",
            mock_create
        )
        
        messages = [{"role": "user", "content": "Hi"}]
        
        # Act
        result = await openai_engine.chat_completion(messages)
        
        # Assert
        assert result["content"] == "Hello! How can I help you?"
        assert result["role"] == "assistant"
        assert result["tokens_used"] == 50
        mock_create.assert_called_once()
    
    @pytest.mark.asyncio
    async def test_chat_completion_with_tools(self, openai_engine, mocker):
        """测试：带工具调用的聊天完成"""
        # Arrange
        mock_response = {
            "choices": [{
                "message": {
                    "role": "assistant",
                    "content": "",
                    "tool_calls": [{
                        "id": "call_123",
                        "type": "function",
                        "function": {
                            "name": "search",
                            "arguments": '{"query": "test"}'
                        }
                    }]
                }
            }]
        }
        
        mocker.patch.object(
            openai_engine.client.chat.completions,
            "create",
            AsyncMock(return_value=mock_response)
        )
        
        messages = [{"role": "user", "content": "Search for test"}]
        tools = [{"type": "function", "function": {"name": "search"}}]
        
        # Act
        result = await openai_engine.chat_completion(messages, tools=tools)
        
        # Assert
        assert "tool_calls" in result
        assert len(result["tool_calls"]) == 1
        assert result["tool_calls"][0]["function"]["name"] == "search"
    
    @pytest.mark.asyncio
    async def test_chat_completion_api_error(self, openai_engine, mocker):
        """测试：API错误处理"""
        # Arrange
        mocker.patch.object(
            openai_engine.client.chat.completions,
            "create",
            AsyncMock(side_effect=Exception("API Error"))
        )
        
        messages = [{"role": "user", "content": "Hi"}]
        
        # Act & Assert
        with pytest.raises(AIEngineError) as exc_info:
            await openai_engine.chat_completion(messages)
        
        assert "API Error" in str(exc_info.value)
    
    @pytest.mark.asyncio
    async def test_stream_completion(self, openai_engine, mocker):
        """测试：流式响应"""
        # Arrange
        async def mock_stream():
            chunks = [
                {"choices": [{"delta": {"content": "Hello"}}]},
                {"choices": [{"delta": {"content": " there"}}]},
                {"choices": [{"delta": {"content": "!"}}]},
            ]
            for chunk in chunks:
                yield chunk
        
        mocker.patch.object(
            openai_engine.client.chat.completions,
            "create",
            return_value=mock_stream()
        )
        
        messages = [{"role": "user", "content": "Hi"}]
        
        # Act
        chunks = []
        async for chunk in openai_engine.stream_completion(messages):
            chunks.append(chunk)
        
        # Assert
        assert len(chunks) == 3
        assert "".join([c["content"] for c in chunks]) == "Hello there!"
```

**测试记忆管理**：

```python
# tests/unit/engines/memory/test_retriever.py
import pytest
from datetime import datetime
from app.engines.memory.retriever import MemoryRetriever
from app.models.memory import Memory

class TestMemoryRetriever:
    """记忆检索器测试"""
    
    @pytest.fixture
    def mock_vector_store(self, mocker):
        """Mock向量数据库"""
        store = mocker.Mock()
        store.search = AsyncMock()
        store.health_check = AsyncMock(return_value=True)
        return store
    
    @pytest.fixture
    def retriever(self, mock_vector_store):
        """检索器实例"""
        return MemoryRetriever(
            vector_store=mock_vector_store,
            cache_ttl=300,
            timeout=0.5
        )
    
    @pytest.mark.asyncio
    async def test_retrieve_memories_both_types(self, retriever, mock_vector_store):
        """测试：检索用户和AI记忆"""
        # Arrange
        mock_vector_store.search.side_effect = [
            # 用户记忆
            [{
                "id": "mem_1",
                "text": "用户说的话",
                "score": 0.9,
                "metadata": {"user_id": "user_1", "role": "user"}
            }],
            # AI记忆
            [{
                "id": "mem_2",
                "text": "AI的回复",
                "score": 0.85,
                "metadata": {"user_id": "user_1", "role": "assistant"}
            }]
        ]
        
        # Act
        result = await retriever.retrieve_memories(
            query="测试查询",
            user_id="user_1",
            memory_type="both"
        )
        
        # Assert
        assert len(result["user_memories"]) == 1
        assert len(result["ai_memories"]) == 1
        assert result["user_memories"][0].content == "用户说的话"
        assert result["ai_memories"][0].content == "AI的回复"
    
    @pytest.mark.asyncio
    async def test_retrieve_memories_with_cache(self, retriever, mock_vector_store):
        """测试：缓存机制"""
        # Arrange
        mock_vector_store.search.return_value = [{
            "id": "mem_1",
            "text": "测试内容",
            "score": 0.9,
            "metadata": {"user_id": "user_1", "role": "user"}
        }]
        
        # Act - 第一次调用
        result1 = await retriever.retrieve_memories(
            query="测试",
            user_id="user_1",
            memory_type="user"
        )
        
        # Act - 第二次调用（应该命中缓存）
        result2 = await retriever.retrieve_memories(
            query="测试",
            user_id="user_1",
            memory_type="user"
        )
        
        # Assert
        assert result1 == result2
        # 向量数据库只应该被调用一次
        assert mock_vector_store.search.call_count == 1
    
    @pytest.mark.asyncio
    async def test_retrieve_memories_timeout(self, retriever, mock_vector_store):
        """测试：超时处理"""
        # Arrange
        import asyncio
        async def slow_search(*args, **kwargs):
            await asyncio.sleep(1.0)  # 超过0.5秒超时
            return []
        
        mock_vector_store.search = slow_search
        
        # Act
        result = await retriever.retrieve_memories(
            query="测试",
            user_id="user_1"
        )
        
        # Assert - 超时应返回空结果
        assert result["user_memories"] == []
        assert result["ai_memories"] == []
    
    @pytest.mark.asyncio
    async def test_retrieve_memories_invalid_type(self, retriever):
        """测试：无效记忆类型"""
        # Act & Assert
        with pytest.raises(ValueError) as exc_info:
            await retriever.retrieve_memories(
                query="测试",
                user_id="user_1",
                memory_type="invalid"
            )
        
        assert "Invalid memory_type" in str(exc_info.value)
```

### 3.2 集成测试规范

**测试完整对话流程**：

```python
# tests/integration/test_chat_flow.py
import pytest
from app.core.orchestrator import CoreOrchestrator
from app.core.personality.manager import PersonalityManager
from app.engines.memory.manager import MemoryManager
from app.engines.tools.manager import ToolManager

@pytest.mark.integration
class TestChatFlow:
    """聊天流程集成测试"""
    
    @pytest.fixture
    async def orchestrator(self, test_db):
        """核心编排器实例"""
        personality_manager = PersonalityManager()
        memory_manager = MemoryManager(test_db)
        tool_manager = ToolManager()
        
        return CoreOrchestrator(
            personality_manager=personality_manager,
            memory_manager=memory_manager,
            tool_manager=tool_manager
        )
    
    @pytest.mark.asyncio
    async def test_complete_chat_flow(self, orchestrator):
        """测试：完整聊天流程"""
        # Arrange
        messages = [
            {"role": "user", "content": "你好，我叫张三"}
        ]
        
        # Act - 第一轮对话
        response1 = await orchestrator.process_chat_request(
            messages=messages,
            user_id="test_user",
            session_id="test_session",
            personality_id="assistant_001",
            stream=False
        )
        
        # Assert - 第一轮
        assert "content" in response1
        assert len(response1["content"]) > 0
        
        # Act - 第二轮对话（应该记住用户名）
        messages.append({"role": "assistant", "content": response1["content"]})
        messages.append({"role": "user", "content": "我刚才说我叫什么？"})
        
        response2 = await orchestrator.process_chat_request(
            messages=messages,
            user_id="test_user",
            session_id="test_session",
            personality_id="assistant_001",
            stream=False
        )
        
        # Assert - 第二轮（应该提到"张三"）
        assert "张三" in response2["content"]
    
    @pytest.mark.asyncio
    async def test_chat_with_tool_calling(self, orchestrator, mocker):
        """测试：带工具调用的对话流程"""
        # Arrange
        messages = [
            {"role": "user", "content": "搜索一下今天的天气"}
        ]
        
        # Mock工具执行
        mock_tool_result = "今天天气晴朗，温度25度"
        mocker.patch(
            "app.engines.tools.manager.ToolManager.execute_tools",
            return_value=[{
                "role": "tool",
                "content": mock_tool_result
            }]
        )
        
        # Act
        response = await orchestrator.process_chat_request(
            messages=messages,
            user_id="test_user",
            session_id="test_session",
            personality_id="assistant_001",
            stream=False
        )
        
        # Assert
        assert "天气" in response["content"]
        assert "25度" in response["content"] or "晴朗" in response["content"]
```

### 3.3 Fixtures和Mock管理

**conftest.py - 共享Fixtures**：

```python
# tests/fixtures/conftest.py
import pytest
import asyncio
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from app.models.base import Base

@pytest.fixture(scope="session")
def event_loop():
    """创建事件循环"""
    loop = asyncio.get_event_loop_policy().new_event_loop()
    yield loop
    loop.close()

@pytest.fixture(scope="function")
def test_db():
    """测试数据库"""
    # 使用内存SQLite
    engine = create_engine("sqlite:///:memory:")
    Base.metadata.create_all(engine)
    
    SessionLocal = sessionmaker(bind=engine)
    session = SessionLocal()
    
    yield session
    
    session.close()
    Base.metadata.drop_all(engine)

@pytest.fixture
def test_user(test_db):
    """测试用户"""
    from app.models.user import User
    user = User(
        id="test_user_001",
        username="testuser",
        email="test@example.com",
        password_hash="hashed_password"
    )
    test_db.add(user)
    test_db.commit()
    return user

@pytest.fixture
def test_personality():
    """测试人格配置"""
    return {
        "id": "test_personality",
        "name": "测试助手",
        "ai": {
            "provider": "openai",
            "model": "gpt-4",
            "temperature": 0.7
        },
        "memory": {
            "enabled": True,
            "save_mode": "both"
        },
        "tools": {
            "enabled": True,
            "allowed_tools": ["search"]
        }
    }

@pytest.fixture
def mock_openai_client(mocker):
    """Mock OpenAI客户端"""
    mock_client = mocker.Mock()
    mock_client.chat.completions.create = AsyncMock()
    return mock_client
```

---

## 4. 前端测试规范

### 4.1 组件测试

```typescript
// src/components/chat/ChatMessage/ChatMessage.test.tsx
import { render, screen, fireEvent } from '@testing-library/react';
import { describe, it, expect, vi } from 'vitest';
import ChatMessage from './ChatMessage';

describe('ChatMessage', () => {
  const defaultProps = {
    role: 'user' as const,
    content: 'Hello, world!',
    timestamp: new Date('2024-01-01T12:00:00'),
  };

  it('renders user message correctly', () => {
    render(<ChatMessage {...defaultProps} />);
    
    expect(screen.getByText('Hello, world!')).toBeInTheDocument();
    expect(screen.getByTestId('user-message')).toBeInTheDocument();
  });

  it('renders assistant message with different style', () => {
    render(<ChatMessage {...defaultProps} role="assistant" />);
    
    const message = screen.getByTestId('assistant-message');
    expect(message).toHaveClass('assistant');
  });

  it('displays loading state', () => {
    render(<ChatMessage {...defaultProps} loading={true} />);
    
    expect(screen.getByTestId('loading-indicator')).toBeInTheDocument();
  });

  it('formats timestamp correctly', () => {
    render(<ChatMessage {...defaultProps} />);
    
    expect(screen.getByText('12:00')).toBeInTheDocument();
  });

  it('calls onClick handler when clicked', () => {
    const handleClick = vi.fn();
    render(<ChatMessage {...defaultProps} onClick={handleClick} />);
    
    fireEvent.click(screen.getByTestId('user-message'));
    
    expect(handleClick).toHaveBeenCalledTimes(1);
  });

  it('renders markdown content for assistant', () => {
    const markdownContent = '**Bold** and *italic*';
    render(<ChatMessage {...defaultProps} role="assistant" content={markdownContent} />);
    
    const boldText = screen.getByText('Bold');
    expect(boldText).toHaveStyle('font-weight: bold');
  });
});
```

### 4.2 Hook测试

```typescript
// src/hooks/useChat.test.ts
import { renderHook, act, waitFor } from '@testing-library/react';
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { useChat } from './useChat';
import * as chatApi from '@/services/chat';

vi.mock('@/services/chat');

describe('useChat', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it('initializes with empty messages', () => {
    const { result } = renderHook(() => useChat('session_123'));
    
    expect(result.current.messages).toEqual([]);
    expect(result.current.loading).toBe(false);
  });

  it('sends message successfully', async () => {
    const mockResponse = {
      role: 'assistant',
      content: 'Hello!',
    };
    
    vi.spyOn(chatApi, 'sendMessage').mockResolvedValue(mockResponse);
    
    const { result } = renderHook(() => useChat('session_123'));
    
    await act(async () => {
      await result.current.sendMessage('Hi');
    });
    
    await waitFor(() => {
      expect(result.current.messages).toHaveLength(2); // user + assistant
      expect(result.current.messages[1].content).toBe('Hello!');
      expect(result.current.loading).toBe(false);
    });
  });

  it('handles error when sending message', async () => {
    vi.spyOn(chatApi, 'sendMessage').mockRejectedValue(new Error('API Error'));
    
    const { result } = renderHook(() => useChat('session_123'));
    
    await act(async () => {
      await result.current.sendMessage('Hi');
    });
    
    await waitFor(() => {
      expect(result.current.error).toBe('发送消息失败');
      expect(result.current.loading).toBe(false);
    });
  });

  it('clears messages', () => {
    const { result } = renderHook(() => useChat('session_123'));
    
    act(() => {
      result.current.clearMessages();
    });
    
    expect(result.current.messages).toEqual([]);
  });
});
```

### 4.3 Redux测试

```typescript
// src/store/slices/chatSlice.test.ts
import { describe, it, expect } from 'vitest';
import chatReducer, { addMessage, clearMessages } from './chatSlice';
import type { ChatState } from './chatSlice';

describe('chatSlice', () => {
  const initialState: ChatState = {
    messages: [],
    loading: false,
    error: null,
  };

  it('handles addMessage', () => {
    const message = {
      id: '1',
      role: 'user',
      content: 'Hello',
      timestamp: new Date(),
    };
    
    const newState = chatReducer(initialState, addMessage(message));
    
    expect(newState.messages).toHaveLength(1);
    expect(newState.messages[0]).toEqual(message);
  });

  it('handles clearMessages', () => {
    const stateWithMessages = {
      ...initialState,
      messages: [
        { id: '1', role: 'user', content: 'Hello', timestamp: new Date() },
      ],
    };
    
    const newState = chatReducer(stateWithMessages, clearMessages());
    
    expect(newState.messages).toEqual([]);
  });
});
```

---

## 5. API测试规范

### 5.1 FastAPI测试客户端

```python
# tests/api/test_chat_api.py
import pytest
from fastapi.testclient import TestClient
from app.main import app

@pytest.fixture
def client():
    """测试客户端"""
    return TestClient(app)

@pytest.fixture
def auth_headers(test_user):
    """认证头"""
    # 生成测试token
    from app.core.user.auth import AuthService
    auth_service = AuthService()
    token = auth_service.create_access_token(
        user_id=test_user.id,
        username=test_user.username,
        role=test_user.role
    )
    return {"Authorization": f"Bearer {token}"}

class TestChatAPI:
    """聊天API测试"""
    
    def test_create_chat_completion_success(self, client, auth_headers, mocker):
        """测试：创建聊天完成 - 成功"""
        # Arrange
        request_data = {
            "messages": [
                {"role": "user", "content": "你好"}
            ],
            "personality_id": "assistant_001",
            "stream": False
        }
        
        # Mock核心编排器
        mock_response = {
            "role": "assistant",
            "content": "你好！我是AI助手。",
            "tokens_used": 20
        }
        mocker.patch(
            "app.core.orchestrator.CoreOrchestrator.process_chat_request",
            return_value=mock_response
        )
        
        # Act
        response = client.post(
            "/v1/chat/completions",
            json=request_data,
            headers=auth_headers
        )
        
        # Assert
        assert response.status_code == 200
        data = response.json()
        assert data["role"] == "assistant"
        assert "你好" in data["content"]
        assert data["tokens_used"] == 20
    
    def test_create_chat_completion_unauthorized(self, client):
        """测试：未授权访问"""
        # Arrange
        request_data = {
            "messages": [{"role": "user", "content": "你好"}],
            "personality_id": "assistant_001"
        }
        
        # Act
        response = client.post("/v1/chat/completions", json=request_data)
        
        # Assert
        assert response.status_code == 401
    
    def test_create_chat_completion_invalid_personality(self, client, auth_headers):
        """测试：无效人格ID"""
        # Arrange
        request_data = {
            "messages": [{"role": "user", "content": "你好"}],
            "personality_id": "invalid_personality"
        }
        
        # Act
        response = client.post(
            "/v1/chat/completions",
            json=request_data,
            headers=auth_headers
        )
        
        # Assert
        assert response.status_code == 404
        assert "Personality not found" in response.json()["detail"]
    
    def test_create_chat_completion_validation_error(self, client, auth_headers):
        """测试：请求参数验证错误"""
        # Arrange
        request_data = {
            "messages": [],  # 空消息列表
            "personality_id": "assistant_001"
        }
        
        # Act
        response = client.post(
            "/v1/chat/completions",
            json=request_data,
            headers=auth_headers
        )
        
        # Assert
        assert response.status_code == 422
    
    def test_stream_chat_completion(self, client, auth_headers, mocker):
        """测试：流式聊天完成"""
        # Arrange
        request_data = {
            "messages": [{"role": "user", "content": "你好"}],
            "personality_id": "assistant_001",
            "stream": True
        }
        
        async def mock_stream():
            chunks = ["你", "好", "！"]
            for chunk in chunks:
                yield {"content": chunk}
        
        mocker.patch(
            "app.core.orchestrator.CoreOrchestrator.process_chat_request",
            return_value=mock_stream()
        )
        
        # Act
        response = client.post(
            "/v1/chat/completions",
            json=request_data,
            headers=auth_headers,
            stream=True
        )
        
        # Assert
        assert response.status_code == 200
        content = b""
        for chunk in response.iter_content():
            content += chunk
        
        assert b"你好！" in content
```

### 5.2 API性能测试

```python
# tests/api/test_performance.py
import pytest
import time
from fastapi.testclient import TestClient
from app.main import app

class TestAPIPerformance:
    """API性能测试"""
    
    def test_chat_api_response_time(self, client, auth_headers):
        """测试：聊天API响应时间应<2秒"""
        request_data = {
            "messages": [{"role": "user", "content": "你好"}],
            "personality_id": "assistant_001"
        }
        
        start = time.time()
        response = client.post(
            "/v1/chat/completions",
            json=request_data,
            headers=auth_headers
        )
        duration = time.time() - start
        
        assert response.status_code == 200
        assert duration < 2.0, f"Response time {duration}s exceeds 2s limit"
    
    def test_concurrent_requests(self, client, auth_headers):
        """测试：并发请求处理"""
        import concurrent.futures
        
        def make_request():
            request_data = {
                "messages": [{"role": "user", "content": "测试"}],
                "personality_id": "assistant_001"
            }
            return client.post(
                "/v1/chat/completions",
                json=request_data,
                headers=auth_headers
            )
        
        # 10个并发请求
        with concurrent.futures.ThreadPoolExecutor(max_workers=10) as executor:
            futures = [executor.submit(make_request) for _ in range(10)]
            results = [f.result() for f in futures]
        
        # 所有请求都应成功
        assert all(r.status_code == 200 for r in results)
```

---

## 6. 集成测试规范

### 6.1 前后端集成测试

```typescript
// frontend/tests/integration/chat.integration.test.ts
import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import axios from 'axios';

describe('Chat Integration Tests', () => {
  const API_URL = 'http://localhost:8000';
  let authToken: string;
  let sessionId: string;

  beforeAll(async () => {
    // 登录获取token
    const response = await axios.post(`${API_URL}/v1/auth/login`, {
      username: 'testuser',
      password: 'testpass',
    });
    authToken = response.data.access_token;
  });

  it('complete chat flow: send message and receive response', async () => {
    // 发送消息
    const chatResponse = await axios.post(
      `${API_URL}/v1/chat/completions`,
      {
        messages: [{ role: 'user', content: '你好' }],
        personality_id: 'assistant_001',
      },
      {
        headers: { Authorization: `Bearer ${authToken}` },
      }
    );

    expect(chatResponse.status).toBe(200);
    expect(chatResponse.data.content).toBeTruthy();
    expect(chatResponse.data.role).toBe('assistant');

    sessionId = chatResponse.data.session_id;
  });

  it('retrieves chat history', async () => {
    const historyResponse = await axios.get(
      `${API_URL}/v1/chat/history/${sessionId}`,
      {
        headers: { Authorization: `Bearer ${authToken}` },
      }
    );

    expect(historyResponse.status).toBe(200);
    expect(historyResponse.data.messages).toHaveLength(2); // user + assistant
  });
});
```

---

## 7. E2E测试规范

### 7.1 Playwright E2E测试

```typescript
// e2e/chat.spec.ts
import { test, expect } from '@playwright/test';

test.describe('Chat Feature E2E', () => {
  test.beforeEach(async ({ page }) => {
    // 登录
    await page.goto('http://localhost:3000/login');
    await page.fill('[data-testid="username-input"]', 'testuser');
    await page.fill('[data-testid="password-input"]', 'testpass');
    await page.click('[data-testid="login-button"]');
    
    // 等待跳转到聊天页面
    await page.waitForURL('**/chat');
  });

  test('user can send message and receive response', async ({ page }) => {
    // 输入消息
    const input = page.locator('[data-testid="chat-input"]');
    await input.fill('你好，请介绍一下自己');
    
    // 发送消息
    await page.click('[data-testid="send-button"]');
    
    // 等待用户消息显示
    await expect(page.locator('[data-testid="user-message"]').last()).toContainText('你好');
    
    // 等待AI响应
    await expect(page.locator('[data-testid="assistant-message"]').last()).toBeVisible({
      timeout: 10000,
    });
    
    // 验证响应内容不为空
    const response = await page.locator('[data-testid="assistant-message"]').last().textContent();
    expect(response).toBeTruthy();
    expect(response!.length).toBeGreaterThan(0);
  });

  test('chat history persists after refresh', async ({ page }) => {
    // 发送消息
    await page.fill('[data-testid="chat-input"]', '记住我叫张三');
    await page.click('[data-testid="send-button"]');
    
    // 等待响应
    await expect(page.locator('[data-testid="assistant-message"]').last()).toBeVisible({
      timeout: 10000,
    });
    
    // 刷新页面
    await page.reload();
    
    // 验证历史消息还在
    await expect(page.locator('[data-testid="user-message"]')).toContainText('记住我叫张三');
  });

  test('voice recording works', async ({ page, context }) => {
    // 授予麦克风权限
    await context.grantPermissions(['microphone']);
    
    // 点击语音按钮
    await page.click('[data-testid="voice-button"]');
    
    // 验证录音状态
    await expect(page.locator('[data-testid="recording-indicator"]')).toBeVisible();
    
    // 等待2秒
    await page.waitForTimeout(2000);
    
    // 停止录音
    await page.click('[data-testid="stop-recording-button"]');
    
    // 验证转写结果
    await expect(page.locator('[data-testid="transcription"]')).toBeVisible({
      timeout: 5000,
    });
  });
});
```

---

## 8. 测试数据管理

### 8.1 测试数据工厂

```python
# tests/fixtures/factories.py
from datetime import datetime
import factory
from app.models.user import User
from app.models.session import Session
from app.models.memory import Memory

class UserFactory(factory.Factory):
    """用户工厂"""
    class Meta:
        model = User
    
    id = factory.Sequence(lambda n: f"user_{n}")
    username = factory.Sequence(lambda n: f"testuser{n}")
    email = factory.Sequence(lambda n: f"test{n}@example.com")
    password_hash = "hashed_password"
    role = "user"
    created_at = factory.LazyFunction(datetime.now)

class SessionFactory(factory.Factory):
    """会话工厂"""
    class Meta:
        model = Session
    
    id = factory.Sequence(lambda n: f"session_{n}")
    user_id = factory.SubFactory(UserFactory)
    title = factory.Faker('sentence')
    created_at = factory.LazyFunction(datetime.now)

class MemoryFactory(factory.Factory):
    """记忆工厂"""
    class Meta:
        model = Memory
    
    id = factory.Sequence(lambda n: f"memory_{n}")
    user_id = factory.SubFactory(UserFactory)
    session_id = factory.SubFactory(SessionFactory)
    role = "user"
    content = factory.Faker('text')
    created_at = factory.LazyFunction(datetime.now)

# 使用示例
def test_with_factory():
    user = UserFactory()
    session = SessionFactory(user_id=user.id)
    memory = MemoryFactory(user_id=user.id, session_id=session.id)
```

### 8.2 测试数据清理

```python
# tests/fixtures/conftest.py
import pytest

@pytest.fixture(autouse=True)
def cleanup_test_data(test_db):
    """自动清理测试数据"""
    yield
    
    # 测试后清理
    from app.models.memory import Memory
    from app.models.session import Session
    from app.models.user import User
    
    test_db.query(Memory).delete()
    test_db.query(Session).delete()
    test_db.query(User).delete()
    test_db.commit()
```

---

## 9. 性能测试

### 9.1 Locust负载测试

```python
# tests/performance/locustfile.py
from locust import HttpUser, task, between

class ChatUser(HttpUser):
    """聊天用户负载测试"""
    wait_time = between(1, 3)
    
    def on_start(self):
        """登录"""
        response = self.client.post("/v1/auth/login", json={
            "username": "testuser",
            "password": "testpass"
        })
        self.token = response.json()["access_token"]
        self.headers = {"Authorization": f"Bearer {self.token}"}
    
    @task(weight=10)
    def send_message(self):
        """发送消息"""
        self.client.post(
            "/v1/chat/completions",
            json={
                "messages": [{"role": "user", "content": "你好"}],
                "personality_id": "assistant_001"
            },
            headers=self.headers
        )
    
    @task(weight=3)
    def get_history(self):
        """获取历史"""
        self.client.get(
            "/v1/chat/history/session_123",
            headers=self.headers
        )
    
    @task(weight=1)
    def get_personalities(self):
        """获取人格列表"""
        self.client.get(
            "/v1/personalities",
            headers=self.headers
        )

# 运行: locust -f locustfile.py --host=http://localhost:8000
```

---

## 10. 测试工具和环境

### 10.1 pytest配置

```ini
# pytest.ini
[pytest]
testpaths = tests
python_files = test_*.py
python_classes = Test*
python_functions = test_*
addopts = 
    -v
    --cov=app
    --cov-report=html
    --cov-report=term
    --cov-report=xml
    --cov-fail-under=80
    --asyncio-mode=auto
markers =
    unit: Unit tests
    integration: Integration tests
    api: API tests
    e2e: End-to-end tests
    slow: Slow running tests
    performance: Performance tests
```

### 10.2 前端测试配置

```typescript
// vitest.config.ts
import { defineConfig } from 'vitest/config';
import react from '@vitejs/plugin-react';

export default defineConfig({
  plugins: [react()],
  test: {
    globals: true,
    environment: 'jsdom',
    setupFiles: './tests/setup.ts',
    coverage: {
      provider: 'v8',
      reporter: ['text', 'json', 'html'],
      exclude: [
        'node_modules/',
        'tests/',
        '**/*.test.{ts,tsx}',
      ],
    },
  },
});
```

---

## 11. CI/CD集成

### 11.1 GitHub Actions工作流

```yaml
# .github/workflows/test.yml
name: Tests

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]

jobs:
  backend-tests:
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: postgres
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
      
      - name: Install dependencies
        run: |
          cd backend
          pip install -r requirements/test.txt
      
      - name: Run tests
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost/test
        run: |
          cd backend
          pytest tests/ \
            --cov=app \
            --cov-report=xml \
            --cov-report=term
      
      - name: Upload coverage
        uses: codecov/codecov-action@v3
        with:
          file: ./backend/coverage.xml

  frontend-tests:
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
      
      - name: Install dependencies
        run: |
          cd frontend
          npm ci
      
      - name: Run tests
        run: |
          cd frontend
          npm run test:coverage
      
      - name: Upload coverage
        uses: codecov/codecov-action@v3
        with:
          file: ./frontend/coverage/coverage-final.json

  e2e-tests:
    runs-on: ubuntu-latest
    needs: [backend-tests, frontend-tests]
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Set up services
        run: |
          docker-compose up -d
      
      - name: Install Playwright
        run: npx playwright install --with-deps
      
      - name: Run E2E tests
        run: npx playwright test
      
      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v3
        with:
          name: playwright-report
          path: playwright-report/
```

---

## 12. 测试最佳实践

### 12.1 测试原则

1. **FIRST原则**
   - **F**ast: 快速
   - **I**ndependent: 独立
   - **R**epeatable: 可重复
   - **S**elf-validating: 自我验证
   - **T**imely: 及时

2. **AAA模式**
   ```python
   def test_example():
       # Arrange - 准备
       user = create_test_user()
       
       # Act - 执行
       result = authenticate_user(user.username, "password")
       
       # Assert - 断言
       assert result.is_authenticated
   ```

3. **一个测试一个断言（建议）**
   ```python
   # 好
   def test_user_creation_sets_username():
       user = create_user("testuser")
       assert user.username == "testuser"
   
   def test_user_creation_sets_email():
       user = create_user("testuser", email="test@example.com")
       assert user.email == "test@example.com"
   
   # 避免
   def test_user_creation():
       user = create_user("testuser", email="test@example.com")
       assert user.username == "testuser"
       assert user.email == "test@example.com"
       assert user.is_active
       assert user.role == "user"
   ```

### 12.2 测试命名

```python
# 好的命名 - 清晰表达意图
def test_retrieve_memories_with_timeout_returns_empty_result():
    pass

def test_authenticate_with_invalid_password_raises_error():
    pass

def test_chat_completion_with_tools_calls_search_function():
    pass

# 不好的命名
def test_memory():
    pass

def test_auth():
    pass

def test_chat():
    pass
```

### 12.3 测试覆盖率目标

```
优先级排序：
1. 核心业务逻辑 - 必须100%
2. API接口 - 必须≥90%
3. 工具函数 - 必须≥85%
4. UI组件 - ≥70%
5. 配置代码 - ≥60%
```

---

## 13. 总结

CozyChat项目的测试体系：

### 13.1 测试层次

```
E2E测试（5%）        → 完整业务流程验证
    ↓
集成测试（15%）      → 模块间交互验证
    ↓
API测试（20%）       → 接口功能验证
    ↓
单元测试（60%）      → 函数/类级别验证
```

### 13.2 测试时机

| 阶段 | 测试类型 | 执行频率 |
|------|---------|---------|
| 开发中 | 单元测试 | 每次保存 |
| 提交前 | 单元测试 + Lint | 每次提交 |
| PR审查 | 单元 + 集成 + API | 每个PR |
| 合并后 | 全部测试 | 每次合并 |
| 发版前 | 全部 + E2E | 发版前 |

### 13.3 质量门禁

```
代码提交检查：
✅ 单元测试通过率 100%
✅ 代码覆盖率 ≥ 80%
✅ Lint检查通过
✅ 类型检查通过
✅ 构建成功

发版检查：
✅ 所有测试通过
✅ E2E测试通过
✅ 性能测试通过
✅ 安全扫描通过
```

---

**文档版本**: v1.0  
**最后更新**: 2025-11-06  
**维护者**: CozyChat Team

