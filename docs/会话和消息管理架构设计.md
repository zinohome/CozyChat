# 会话和消息管理架构设计

## 一、设计原则

### 1.1 职责分离
- **数据库**：唯一真实数据源，持久化存储，按 `user_id` 隔离
- **React Query**：服务端状态缓存，管理数据同步和失效
- **Zustand**：客户端 UI 状态，不存储服务端数据

### 1.2 数据流向
```
用户操作 → React 组件 → React Query → API → 数据库
                ↓
            Zustand (UI状态)
```

### 1.3 用户隔离
- 数据库层面：所有查询都带 `user_id` 过滤
- API 层面：通过 `get_current_active_user` 获取当前用户
- 前端层面：React Query 缓存按用户隔离（可选）

## 二、数据存储设计

### 2.1 数据库（PostgreSQL）

#### Sessions 表
```sql
CREATE TABLE sessions (
    id UUID PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    personality_id VARCHAR(100) NOT NULL,
    title VARCHAR(255) NOT NULL DEFAULT '新会话',
    message_count INTEGER NOT NULL DEFAULT 0,
    total_tokens_used BIGINT NOT NULL DEFAULT 0,
    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP NOT NULL DEFAULT NOW(),
    last_message_at TIMESTAMP,
    deleted_at TIMESTAMP,
    INDEX idx_sessions_user_id (user_id),
    INDEX idx_sessions_user_created (user_id, created_at DESC)
);
```

**特点**：
- 通过 `user_id` 字段实现用户隔离
- 软删除（`deleted_at`）
- 索引优化查询性能

#### Messages 表
```sql
CREATE TABLE messages (
    id UUID PRIMARY KEY,
    session_id UUID NOT NULL REFERENCES sessions(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    role VARCHAR(20) NOT NULL CHECK (role IN ('user', 'assistant', 'system', 'tool')),
    content TEXT NOT NULL,
    model VARCHAR(100),
    tokens_used JSONB,
    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    INDEX idx_messages_session_id (session_id),
    INDEX idx_messages_user_id (user_id),
    INDEX idx_messages_session_created (session_id, created_at)
);
```

**特点**：
- 通过 `session_id` 关联会话
- 通过 `user_id` 实现用户隔离
- 级联删除（删除会话时自动删除消息）

### 2.2 React Query 缓存结构

```typescript
// 会话列表（按用户隔离）
{
  ['sessions', userId]: Session[]
}

// 单个会话详情（包含消息）
{
  ['session', sessionId]: SessionDetail
}

// 会话消息列表（按会话隔离）
{
  ['chat', 'messages', sessionId]: Message[]
}
```

**特点**：
- 缓存键包含 `sessionId`，自动按会话隔离
- 可以添加 `userId` 到缓存键实现用户隔离（可选）
- 自动处理缓存失效和同步

### 2.3 Zustand Store 结构

```typescript
interface ChatState {
  // 客户端状态
  currentSessionId: string | null;        // 当前选中的会话ID
  currentUserId: string | null;          // 当前用户ID（用于缓存隔离）
  
  // UI 状态
  isSidebarOpen: boolean;                // 侧边栏开关
  isSettingsOpen: boolean;               // 设置面板开关
  inputValue: string;                    // 输入框内容（临时状态）
  
  // 加载状态（可选，也可以从 React Query 获取）
  isLoading: boolean;
  error: string | null;
}
```

**特点**：
- **不存储**服务端数据（sessions、messages）
- 只存储客户端 UI 状态
- 可以持久化到 localStorage（只持久化 UI 状态）

## 三、会话生命周期设计

### 3.1 创建会话

#### 数据流
```
用户点击"新建会话"
  ↓
React 组件调用 createSession()
  ↓
React Query Mutation
  ↓
API: POST /v1/sessions
  ↓
后端：创建 Session 记录（带 user_id）
  ↓
返回新会话对象
  ↓
React Query 更新缓存 ['sessions', userId]
  ↓
Zustand 更新 currentSessionId
  ↓
组件自动切换到新会话
```

#### 实现代码

**前端（React Query）**：
```typescript
// useSessions.ts
const createMutation = useMutation({
  mutationFn: (request: CreateSessionRequest) => 
    sessionApi.createSession(request),
  onSuccess: (newSession, variables, context) => {
    const userId = useAuthStore.getState().currentUserId;
    
    // 更新会话列表缓存
    queryClient.setQueryData(
      ['sessions', userId],
      (old: Session[] = []) => [newSession, ...old]
    );
    
    // 创建空的消息缓存
    queryClient.setQueryData(
      ['chat', 'messages', newSession.id],
      []
    );
    
    // 更新当前会话ID
    useChatStore.getState().setCurrentSessionId(newSession.id);
  },
});
```

**后端（数据库）**：
```python
# sessions.py
@router.post("", response_model=CreateSessionResponse)
async def create_session(
    request: CreateSessionRequest,
    user: User = Depends(get_current_active_user),  # 自动获取当前用户
    db: Session = Depends(get_sync_session)
):
    # 创建会话（自动关联 user_id）
    session = SessionModel(
        user_id=user.id,  # ✅ 用户隔离
        personality_id=request.personality_id,
        title=request.title or "新会话"
    )
    db.add(session)
    db.commit()
    db.refresh(session)
    return CreateSessionResponse(session_id=str(session.id), ...)
```

### 3.2 切换会话

#### 数据流
```
用户点击侧边栏会话项
  ↓
URL 变化：/chat/{sessionId}
  ↓
React 组件接收新的 sessionId prop
  ↓
Zustand 更新 currentSessionId
  ↓
React Query 自动查询 ['chat', 'messages', sessionId]
  ↓
如果缓存不存在，从 API 加载
  ↓
API: GET /v1/sessions/{sessionId}
  ↓
后端：查询 Session 和 Messages（带 user_id 过滤）
  ↓
返回会话详情和消息列表
  ↓
React Query 更新缓存
  ↓
组件自动渲染新会话的消息
```

#### 实现代码

**前端（组件）**：
```typescript
// EnhancedChatContainer.tsx
export const EnhancedChatContainer: React.FC<Props> = ({ sessionId }) => {
  const { currentSessionId, setCurrentSessionId } = useChatStore();
  const userId = useAuthStore.getState().currentUserId;
  
  // 切换会话时更新 Zustand
  useEffect(() => {
    if (sessionId !== currentSessionId) {
      setCurrentSessionId(sessionId);
    }
  }, [sessionId, currentSessionId]);
  
  // 从 React Query 获取消息（自动按 sessionId 隔离）
  const { data: messages = [], isLoading } = useQuery({
    queryKey: ['chat', 'messages', sessionId],
    queryFn: () => chatApi.getHistory(sessionId),
    enabled: !!sessionId && sessionId !== 'default',
    staleTime: 5 * 60 * 1000, // 5分钟
  });
  
  // 渲染消息（直接使用，不需要过滤）
  return (
    <div>
      {messages.map(msg => <MessageBubble key={msg.id} message={msg} />)}
    </div>
  );
};
```

**后端（数据库查询）**：
```python
# sessions.py
@router.get("/{session_id}", response_model=SessionDetailResponse)
async def get_session(
    session_id: str,
    user: User = Depends(get_current_active_user),  # ✅ 用户隔离
    db: Session = Depends(get_sync_session)
):
    session_uuid = uuid.UUID(session_id)
    
    # 查询会话（必须属于当前用户）
    session = db.query(SessionModel).filter(
        and_(
            SessionModel.id == session_uuid,
            SessionModel.user_id == user.id,  # ✅ 用户隔离
            SessionModel.deleted_at.is_(None)
        )
    ).first()
    
    if not session:
        raise HTTPException(404, "Session not found")
    
    # 查询消息（通过 session_id 关联，自动用户隔离）
    messages = db.query(MessageModel).filter(
        MessageModel.session_id == session_uuid
    ).order_by(MessageModel.created_at).all()
    
    return SessionDetailResponse(...)
```

### 3.3 发送消息

#### 数据流
```
用户输入消息，点击发送
  ↓
React 组件调用 sendStreamMessage()
  ↓
立即添加到 React Query 缓存（乐观更新）
  ↓
发送流式请求到后端
  ↓
后端：保存用户消息到数据库（带 user_id）
  ↓
后端：生成 AI 回复
  ↓
后端：保存 AI 消息到数据库（带 user_id）
  ↓
后端：更新 Session.message_count
  ↓
流式返回 AI 回复
  ↓
React Query 实时更新缓存
  ↓
组件自动渲染新消息
```

#### 实现代码

**前端（React Query）**：
```typescript
// useStreamChat.ts
const sendStreamMessage = useCallback(async (content: string) => {
  // 1. 乐观更新：立即添加到缓存
  const userMessage: Message = {
    id: `user-${Date.now()}`,
    role: 'user',
    content,
    session_id: sessionId,
    timestamp: new Date(),
  };
  
  queryClient.setQueryData(
    ['chat', 'messages', sessionId],
    (old: Message[] = []) => [...old, userMessage]
  );
  
  // 2. 创建 AI 消息占位符
  const aiMessageId = `assistant-${Date.now()}`;
  const aiMessage: Message = {
    id: aiMessageId,
    role: 'assistant',
    content: '',
    session_id: sessionId,
    timestamp: new Date(),
  };
  
  queryClient.setQueryData(
    ['chat', 'messages', sessionId],
    (old: Message[] = []) => [...old, aiMessage]
  );
  
  // 3. 发送流式请求
  const stream = chatApi.streamChat({
    messages: [...messages, { role: 'user', content }],
    session_id: sessionId,
    personality_id: personalityId,
    stream: true,
  });
  
  // 4. 流式更新缓存
  for await (const chunk of stream) {
    queryClient.setQueryData(
      ['chat', 'messages', sessionId],
      (old: Message[] = []) => 
        old.map(msg => 
          msg.id === aiMessageId 
            ? { ...msg, content: msg.content + chunk.content }
            : msg
        )
    );
  }
  
  // 5. 完成后刷新会话列表（标题可能更新）
  setTimeout(() => {
    queryClient.invalidateQueries({ 
      queryKey: ['sessions', userId] 
    });
  }, 3000);
}, [sessionId, personalityId, userId]);
```

**后端（数据库）**：
```python
# chat.py
async def create_chat_completion(
    request: ChatCompletionRequest,
    user: User = Depends(get_current_active_user),  # ✅ 用户隔离
    db: Session = Depends(get_sync_session)
):
    # 验证会话属于当前用户
    session = db.query(SessionModel).filter(
        and_(
            SessionModel.id == uuid.UUID(request.session_id),
            SessionModel.user_id == user.id,  # ✅ 用户隔离
            SessionModel.deleted_at.is_(None)
        )
    ).first()
    
    if not session:
        raise HTTPException(404, "Session not found")
    
    # 生成 AI 回复...
    
    # 异步保存消息到数据库
    async def save_messages():
        # 保存用户消息
        user_msg = MessageModel(
            session_id=session.id,
            user_id=user.id,  # ✅ 用户隔离
            role='user',
            content=last_user_message
        )
        db.add(user_msg)
        
        # 保存 AI 消息
        ai_msg = MessageModel(
            session_id=session.id,
            user_id=user.id,  # ✅ 用户隔离
            role='assistant',
            content=assistant_content,
            model=model
        )
        db.add(ai_msg)
        
        # 更新会话统计
        session.message_count += 2
        session.last_message_at = datetime.utcnow()
        
        db.commit()
    
    asyncio.create_task(save_messages())
```

### 3.4 修改会话标题

#### 数据流
```
用户点击会话标题，输入新标题
  ↓
React 组件调用 updateSession()
  ↓
React Query Mutation
  ↓
API: PUT /v1/sessions/{sessionId}
  ↓
后端：更新 Session.title（带 user_id 验证）
  ↓
返回更新后的会话对象
  ↓
React Query 更新缓存 ['sessions', userId]
  ↓
组件自动显示新标题
```

#### 实现代码

**前端（React Query）**：
```typescript
// useSessions.ts
const updateMutation = useMutation({
  mutationFn: ({ sessionId, request }: { 
    sessionId: string; 
    request: UpdateSessionRequest 
  }) => sessionApi.updateSession(sessionId, request),
  onSuccess: (updatedSession) => {
    const userId = useAuthStore.getState().currentUserId;
    
    // 更新会话列表缓存
    queryClient.setQueryData(
      ['sessions', userId],
      (old: Session[] = []) =>
        old.map(s => 
          (s.id || s.session_id) === updatedSession.id 
            ? updatedSession 
            : s
        )
    );
    
    // 更新会话详情缓存
    queryClient.setQueryData(
      ['session', updatedSession.id],
      updatedSession
    );
  },
});
```

**后端（数据库）**：
```python
# sessions.py
@router.put("/{session_id}", response_model=UpdateSessionResponse)
async def update_session(
    session_id: str,
    request: UpdateSessionRequest,
    user: User = Depends(get_current_active_user),  # ✅ 用户隔离
    db: Session = Depends(get_sync_session)
):
    session_uuid = uuid.UUID(session_id)
    
    # 查询会话（必须属于当前用户）
    session = db.query(SessionModel).filter(
        and_(
            SessionModel.id == session_uuid,
            SessionModel.user_id == user.id,  # ✅ 用户隔离
            SessionModel.deleted_at.is_(None)
        )
    ).first()
    
    if not session:
        raise HTTPException(404, "Session not found")
    
    # 更新标题
    if request.title is not None:
        session.title = request.title
        session.updated_at = datetime.utcnow()
    
    db.commit()
    db.refresh(session)
    
    return UpdateSessionResponse(...)
```

### 3.5 删除会话

#### 数据流
```
用户点击删除按钮
  ↓
React 组件调用 deleteSession()
  ↓
React Query Mutation
  ↓
API: DELETE /v1/sessions/{sessionId}
  ↓
后端：软删除 Session（设置 deleted_at，带 user_id 验证）
  ↓
后端：级联删除 Messages（数据库自动处理）
  ↓
返回删除成功
  ↓
React Query 从缓存移除
  ↓
如果删除的是当前会话，切换到其他会话或清空
```

#### 实现代码

**前端（React Query）**：
```typescript
// useSessions.ts
const deleteMutation = useMutation({
  mutationFn: (sessionId: string) => 
    sessionApi.deleteSession(sessionId),
  onSuccess: (_, sessionId) => {
    const userId = useAuthStore.getState().currentUserId;
    const { currentSessionId, setCurrentSessionId } = useChatStore.getState();
    
    // 如果删除的是当前会话，切换到其他会话
    if (currentSessionId === sessionId) {
      // 获取会话列表，切换到第一个
      const sessions = queryClient.getQueryData<Session[]>(['sessions', userId]) || [];
      const remainingSessions = sessions.filter(
        s => (s.id || s.session_id) !== sessionId
      );
      
      if (remainingSessions.length > 0) {
        setCurrentSessionId(remainingSessions[0].id || remainingSessions[0].session_id);
      } else {
        setCurrentSessionId(null);
      }
    }
    
    // 从会话列表缓存移除
    queryClient.setQueryData(
      ['sessions', userId],
      (old: Session[] = []) =>
        old.filter(s => (s.id || s.session_id) !== sessionId)
    );
    
    // 移除会话详情和消息缓存
    queryClient.removeQueries({ 
      queryKey: ['session', sessionId] 
    });
    queryClient.removeQueries({ 
      queryKey: ['chat', 'messages', sessionId] 
    });
  },
});
```

**后端（数据库）**：
```python
# sessions.py
@router.delete("/{session_id}", response_model=DeleteSessionResponse)
async def delete_session(
    session_id: str,
    user: User = Depends(get_current_active_user),  # ✅ 用户隔离
    db: Session = Depends(get_sync_session)
):
    session_uuid = uuid.UUID(session_id)
    
    # 查询会话（必须属于当前用户）
    session = db.query(SessionModel).filter(
        and_(
            SessionModel.id == session_uuid,
            SessionModel.user_id == user.id,  # ✅ 用户隔离
            SessionModel.deleted_at.is_(None)
        )
    ).first()
    
    if not session:
        raise HTTPException(404, "Session not found")
    
    # 软删除（设置 deleted_at）
    session.deleted_at = datetime.utcnow()
    
    # 级联删除消息（数据库自动处理，因为设置了 CASCADE）
    # 或者手动删除：
    # db.query(MessageModel).filter(
    #     MessageModel.session_id == session_uuid
    # ).delete()
    
    db.commit()
    
    return DeleteSessionResponse(session_id=session_id)
```

## 四、多会话并存和切换

### 4.1 会话列表管理

**React Query 缓存**：
```typescript
// 获取会话列表（按用户隔离）
const { data: sessions = [] } = useQuery({
  queryKey: ['sessions', userId],
  queryFn: () => sessionApi.getSessions(),
  staleTime: 1 * 60 * 1000, // 1分钟
});

// 会话列表自动按用户隔离
// 不同用户的缓存键不同：['sessions', userId1] vs ['sessions', userId2]
```

**后端查询（用户隔离）**：
```python
# sessions.py
@router.get("", response_model=SessionsListResponse)
async def list_sessions(
    user: User = Depends(get_current_active_user),  # ✅ 用户隔离
    db: Session = Depends(get_sync_session)
):
    # 只查询当前用户的会话
    sessions = db.query(SessionModel).filter(
        and_(
            SessionModel.user_id == user.id,  # ✅ 用户隔离
            SessionModel.deleted_at.is_(None)
        )
    ).order_by(SessionModel.last_message_at.desc()).all()
    
    return SessionsListResponse(items=[s.to_dict() for s in sessions])
```

### 4.2 切换会话

**组件实现**：
```typescript
// EnhancedChatContainer.tsx
export const EnhancedChatContainer: React.FC<Props> = ({ sessionId }) => {
  const { currentSessionId, setCurrentSessionId } = useChatStore();
  
  // 切换会话时更新状态
  useEffect(() => {
    if (sessionId && sessionId !== currentSessionId) {
      setCurrentSessionId(sessionId);
    }
  }, [sessionId, currentSessionId]);
  
  // 每个会话的消息独立缓存
  const { data: messages = [] } = useQuery({
    queryKey: ['chat', 'messages', sessionId],
    queryFn: () => chatApi.getHistory(sessionId),
    enabled: !!sessionId && sessionId !== 'default',
  });
  
  // 直接使用 messages，不需要过滤
  return (
    <div>
      {messages.map(msg => <MessageBubble key={msg.id} message={msg} />)}
    </div>
  );
};
```

**特点**：
- 每个会话的消息独立缓存（`['chat', 'messages', sessionId]`）
- 切换会话时自动从缓存加载（如果存在）
- 如果缓存不存在，自动从 API 加载
- 不同会话的消息不会混淆

### 4.3 并发操作

**场景**：用户在会话A发送消息，同时切换到会话B

**处理**：
```typescript
// 发送消息时，只更新对应会话的缓存
queryClient.setQueryData(
  ['chat', 'messages', sessionId],  // 只更新当前会话
  (old) => [...old, newMessage]
);

// 切换会话时，自动加载新会话的消息
// React Query 自动处理，不会影响其他会话的缓存
```

## 五、用户隔离实现

### 5.1 数据库层面

**所有查询都带 user_id 过滤**：
```python
# 查询会话
db.query(SessionModel).filter(
    SessionModel.user_id == user.id  # ✅ 用户隔离
)

# 查询消息（通过 session_id 间接隔离）
db.query(MessageModel).filter(
    MessageModel.session_id == session_uuid
)
# 因为 session 已经验证了 user_id，所以消息自动隔离
```

### 5.2 API 层面

**使用依赖注入获取当前用户**：
```python
@router.get("/{session_id}")
async def get_session(
    session_id: str,
    user: User = Depends(get_current_active_user),  # ✅ 自动获取当前用户
    db: Session = Depends(get_sync_session)
):
    # 所有操作都基于 user.id
    session = db.query(SessionModel).filter(
        SessionModel.user_id == user.id  # ✅ 用户隔离
    ).first()
```

### 5.3 前端层面（可选）

**React Query 缓存键包含 userId**：
```typescript
// 会话列表缓存（按用户隔离）
['sessions', userId]

// 会话详情缓存（可选，因为后端已经隔离）
['session', sessionId]  // 或者 ['session', userId, sessionId]
```

**Zustand Store 存储当前用户ID**：
```typescript
interface ChatState {
  currentUserId: string | null;  // 当前用户ID
  currentSessionId: string | null;
}
```

## 六、完整的数据流示例

### 6.1 用户A创建会话

```
1. 用户A点击"新建会话"
2. React Query Mutation: createSession()
3. API: POST /v1/sessions (Header: Authorization: Bearer tokenA)
4. 后端: get_current_active_user() → 返回用户A
5. 数据库: INSERT INTO sessions (user_id='userA', ...)
6. 返回: { id: 'session1', user_id: 'userA', ... }
7. React Query: 更新 ['sessions', 'userA'] 缓存
8. Zustand: 更新 currentSessionId = 'session1'
```

### 6.2 用户A切换到会话2

```
1. 用户A点击会话2
2. URL变化: /chat/session2
3. Zustand: 更新 currentSessionId = 'session2'
4. React Query: 查询 ['chat', 'messages', 'session2']
5. 如果缓存不存在:
   - API: GET /v1/sessions/session2 (Header: Authorization: Bearer tokenA)
   - 后端: 验证 session2.user_id == 'userA' ✅
   - 返回: 会话详情和消息列表
   - React Query: 更新缓存
6. 组件: 渲染会话2的消息
```

### 6.3 用户A发送消息

```
1. 用户A在会话1输入消息，点击发送
2. React Query: 乐观更新 ['chat', 'messages', 'session1']
3. API: POST /v1/chat/completions (session_id='session1', Header: tokenA)
4. 后端: 验证 session1.user_id == 'userA' ✅
5. 数据库: INSERT INTO messages (session_id='session1', user_id='userA', ...)
6. 流式返回 AI 回复
7. React Query: 实时更新 ['chat', 'messages', 'session1']
8. 组件: 实时渲染新消息
```

### 6.4 用户B尝试访问用户A的会话

```
1. 用户B尝试访问 /chat/session1
2. API: GET /v1/sessions/session1 (Header: Authorization: Bearer tokenB)
3. 后端: get_current_active_user() → 返回用户B
4. 数据库查询: 
   SELECT * FROM sessions 
   WHERE id='session1' AND user_id='userB'  -- ❌ 找不到
5. 后端: 返回 404 "Session not found"
6. 前端: 显示错误，不允许访问
```

## 七、总结

### 7.1 架构优势

1. **职责清晰**：
   - 数据库：持久化存储，用户隔离
   - React Query：服务端状态缓存，数据同步
   - Zustand：客户端 UI 状态

2. **用户隔离**：
   - 数据库层面：所有查询带 `user_id` 过滤
   - API 层面：通过 `get_current_active_user` 自动隔离
   - 前端层面：可选，通过缓存键隔离

3. **多会话支持**：
   - 每个会话的消息独立缓存
   - 切换会话时自动加载
   - 不会混淆不同会话的消息

4. **数据一致性**：
   - 单一数据源（数据库）
   - React Query 自动同步
   - 乐观更新提升用户体验

### 7.2 关键点

- ✅ **移除 Zustand 的 messages 存储**
- ✅ **所有服务端数据通过 React Query 管理**
- ✅ **Zustand 只存储客户端 UI 状态**
- ✅ **数据库层面实现用户隔离**
- ✅ **每个会话的消息独立缓存**

