# CozyChat 后端架构设计（续）

## 2.3 记忆管理系统 (Memory System)

### 2.3.1 设计目标

1. **区分用户记忆和AI记忆**: 用户说的话和AI说的话分开存储和检索
2. **语义搜索**: 基于向量数据库的语义检索
3. **异步处理**: 记忆保存和检索异步化，不阻塞主流程
4. **缓存优化**: TTL缓存减少数据库访问
5. **重要性评分**: 根据重要性过滤和淘汰记忆

### 2.3.2 记忆数据结构

```python
# app/engines/memory/models.py
from datetime import datetime
from typing import Optional, Dict, Any
from enum import Enum

class MemoryType(Enum):
    USER = "user"       # 用户记忆
    ASSISTANT = "ai"    # AI记忆
    SYSTEM = "system"   # 系统记忆

class Memory:
    """记忆对象"""
    
    def __init__(
        self,
        id: str,
        user_id: str,
        session_id: str,
        memory_type: MemoryType,
        content: str,
        embedding: list[float],
        importance: float = 0.5,
        metadata: Optional[Dict[str, Any]] = None,
        created_at: Optional[datetime] = None,
        expires_at: Optional[datetime] = None
    ):
        self.id = id
        self.user_id = user_id
        self.session_id = session_id
        self.memory_type = memory_type
        self.content = content
        self.embedding = embedding
        self.importance = importance
        self.metadata = metadata or {}
        self.created_at = created_at or datetime.now()
        self.expires_at = expires_at
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "id": self.id,
            "user_id": self.user_id,
            "session_id": self.session_id,
            "memory_type": self.memory_type.value,
            "content": self.content,
            "importance": self.importance,
            "metadata": self.metadata,
            "created_at": self.created_at.isoformat(),
            "expires_at": self.expires_at.isoformat() if self.expires_at else None
        }
```

### 2.3.3 记忆引擎基类

```python
# app/engines/memory/base.py
from abc import ABC, abstractmethod
from typing import List, Optional
from app.engines.memory.models import Memory, MemoryType

class MemoryEngineBase(ABC):
    """记忆引擎基类"""
    
    @abstractmethod
    async def add_memory(self, memory: Memory) -> str:
        """添加记忆"""
        pass
    
    @abstractmethod
    async def search_memories(
        self,
        query: str,
        user_id: str,
        session_id: Optional[str] = None,
        memory_type: Optional[MemoryType] = None,
        limit: int = 5,
        similarity_threshold: float = 0.7
    ) -> List[Memory]:
        """搜索相关记忆"""
        pass
    
    @abstractmethod
    async def delete_memory(self, memory_id: str) -> bool:
        """删除记忆"""
        pass
    
    @abstractmethod
    async def delete_session_memories(
        self,
        user_id: str,
        session_id: str
    ) -> int:
        """删除会话的所有记忆"""
        pass
    
    @abstractmethod
    async def get_memory_stats(self, user_id: str) -> Dict[str, Any]:
        """获取记忆统计信息"""
        pass
```

### 2.3.4 ChromaDB实现

```python
# app/engines/memory/chromadb_engine.py
import chromadb
from chromadb.config import Settings
from typing import List, Optional, Dict, Any
import uuid
from datetime import datetime, timedelta
from app.engines.memory.base import MemoryEngineBase
from app.engines.memory.models import Memory, MemoryType
from app.utils.logger import logger

class ChromaDBMemoryEngine(MemoryEngineBase):
    """ChromaDB记忆引擎实现"""
    
    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.client = chromadb.Client(Settings(
            chroma_db_impl=config.get("impl", "duckdb+parquet"),
            persist_directory=config.get("persist_directory", "./chroma_db")
        ))
        
        # 创建集合（区分用户记忆和AI记忆）
        self.user_collection = self.client.get_or_create_collection(
            name=config.get("user_collection", "user_memories"),
            metadata={"type": "user"}
        )
        self.ai_collection = self.client.get_or_create_collection(
            name=config.get("ai_collection", "ai_memories"),
            metadata={"type": "ai"}
        )
    
    def _get_collection(self, memory_type: MemoryType):
        """根据记忆类型获取集合"""
        if memory_type == MemoryType.USER:
            return self.user_collection
        elif memory_type == MemoryType.ASSISTANT:
            return self.ai_collection
        else:
            raise ValueError(f"Unsupported memory type: {memory_type}")
    
    async def add_memory(self, memory: Memory) -> str:
        """添加记忆到向量数据库"""
        collection = self._get_collection(memory.memory_type)
        
        # 准备元数据
        metadata = {
            "user_id": memory.user_id,
            "session_id": memory.session_id,
            "importance": memory.importance,
            "created_at": memory.created_at.timestamp(),
            **memory.metadata
        }
        
        if memory.expires_at:
            metadata["expires_at"] = memory.expires_at.timestamp()
        
        # 添加到集合
        collection.add(
            ids=[memory.id],
            documents=[memory.content],
            embeddings=[memory.embedding],
            metadatas=[metadata]
        )
        
        logger.debug(f"Added {memory.memory_type.value} memory: {memory.id}")
        return memory.id
    
    async def search_memories(
        self,
        query: str,
        user_id: str,
        session_id: Optional[str] = None,
        memory_type: Optional[MemoryType] = None,
        limit: int = 5,
        similarity_threshold: float = 0.7
    ) -> List[Memory]:
        """搜索相关记忆"""
        
        # 如果指定记忆类型，只搜索该类型
        collections_to_search = []
        if memory_type:
            collections_to_search.append((self._get_collection(memory_type), memory_type))
        else:
            # 否则搜索所有类型
            collections_to_search.extend([
                (self.user_collection, MemoryType.USER),
                (self.ai_collection, MemoryType.ASSISTANT)
            ])
        
        all_results = []
        
        for collection, mem_type in collections_to_search:
            # 构建where条件
            where = {"user_id": user_id}
            if session_id:
                where["session_id"] = session_id
            
            # 查询
            results = collection.query(
                query_texts=[query],
                n_results=limit,
                where=where
            )
            
            # 转换为Memory对象
            if results['ids'] and results['ids'][0]:
                for i, doc_id in enumerate(results['ids'][0]):
                    distance = results['distances'][0][i] if results['distances'] else 0
                    similarity = 1 - distance
                    
                    # 过滤相似度低于阈值的
                    if similarity < similarity_threshold:
                        continue
                    
                    metadata = results['metadatas'][0][i]
                    
                    # 检查是否过期
                    if 'expires_at' in metadata:
                        expires_at = datetime.fromtimestamp(metadata['expires_at'])
                        if datetime.now() > expires_at:
                            continue
                    
                    memory = Memory(
                        id=doc_id,
                        user_id=metadata['user_id'],
                        session_id=metadata['session_id'],
                        memory_type=mem_type,
                        content=results['documents'][0][i],
                        embedding=[],  # 不返回embedding
                        importance=metadata.get('importance', 0.5),
                        metadata={
                            'similarity': similarity,
                            **{k: v for k, v in metadata.items() 
                               if k not in ['user_id', 'session_id', 'importance', 'created_at', 'expires_at']}
                        },
                        created_at=datetime.fromtimestamp(metadata['created_at'])
                    )
                    all_results.append(memory)
        
        # 按相似度排序
        all_results.sort(key=lambda m: m.metadata.get('similarity', 0), reverse=True)
        return all_results[:limit]
    
    async def delete_memory(self, memory_id: str) -> bool:
        """删除记忆"""
        try:
            # 尝试从两个集合中删除
            for collection in [self.user_collection, self.ai_collection]:
                try:
                    collection.delete(ids=[memory_id])
                    logger.debug(f"Deleted memory: {memory_id}")
                    return True
                except:
                    continue
            return False
        except Exception as e:
            logger.error(f"Failed to delete memory {memory_id}: {e}")
            return False
    
    async def delete_session_memories(
        self,
        user_id: str,
        session_id: str
    ) -> int:
        """删除会话的所有记忆"""
        deleted_count = 0
        where = {"user_id": user_id, "session_id": session_id}
        
        for collection in [self.user_collection, self.ai_collection]:
            try:
                collection.delete(where=where)
                deleted_count += 1
            except Exception as e:
                logger.error(f"Failed to delete session memories: {e}")
        
        return deleted_count
    
    async def get_memory_stats(self, user_id: str) -> Dict[str, Any]:
        """获取记忆统计信息"""
        stats = {
            "user_memories": 0,
            "ai_memories": 0,
            "total_memories": 0
        }
        
        # 统计用户记忆
        user_results = self.user_collection.get(where={"user_id": user_id})
        stats["user_memories"] = len(user_results['ids']) if user_results['ids'] else 0
        
        # 统计AI记忆
        ai_results = self.ai_collection.get(where={"user_id": user_id})
        stats["ai_memories"] = len(ai_results['ids']) if ai_results['ids'] else 0
        
        stats["total_memories"] = stats["user_memories"] + stats["ai_memories"]
        
        return stats
```

### 2.3.5 记忆管理器

```python
# app/engines/memory/manager.py
from typing import List, Optional, Dict, Any
from datetime import datetime, timedelta
import asyncio
from cachetools import TTLCache
from app.engines.memory.base import MemoryEngineBase
from app.engines.memory.models import Memory, MemoryType
from app.utils.logger import logger

class MemoryManager:
    """记忆管理器 - 统一管理记忆的保存和检索"""
    
    def __init__(
        self,
        engine: MemoryEngineBase,
        embedding_func,  # 向量化函数
        cache_ttl: int = 300,
        cache_maxsize: int = 100
    ):
        self.engine = engine
        self.embedding_func = embedding_func
        
        # 缓存：减少重复查询
        self.cache = TTLCache(maxsize=cache_maxsize, ttl=cache_ttl)
        
        # 重要性评估器（可以后续用ML模型替换）
        self.importance_evaluator = self._default_importance_evaluator
    
    def _default_importance_evaluator(self, content: str, metadata: Dict) -> float:
        """默认重要性评估（简单规则）"""
        importance = 0.5
        
        # 长度因素
        if len(content) > 100:
            importance += 0.1
        
        # 关键词因素
        keywords = ["重要", "必须", "记住", "请记住", "不要忘记"]
        if any(kw in content for kw in keywords):
            importance += 0.2
        
        # 问题因素
        if "?" in content or "？" in content:
            importance += 0.1
        
        return min(importance, 1.0)
    
    async def save_user_memory(
        self,
        user_id: str,
        session_id: str,
        content: str,
        metadata: Optional[Dict] = None,
        ttl_days: int = 90
    ) -> str:
        """保存用户记忆"""
        return await self._save_memory(
            user_id=user_id,
            session_id=session_id,
            content=content,
            memory_type=MemoryType.USER,
            metadata=metadata,
            ttl_days=ttl_days
        )
    
    async def save_ai_memory(
        self,
        user_id: str,
        session_id: str,
        content: str,
        metadata: Optional[Dict] = None,
        ttl_days: int = 30
    ) -> str:
        """保存AI记忆"""
        return await self._save_memory(
            user_id=user_id,
            session_id=session_id,
            content=content,
            memory_type=MemoryType.ASSISTANT,
            metadata=metadata,
            ttl_days=ttl_days
        )
    
    async def _save_memory(
        self,
        user_id: str,
        session_id: str,
        content: str,
        memory_type: MemoryType,
        metadata: Optional[Dict] = None,
        ttl_days: int = 90
    ) -> str:
        """内部方法：保存记忆"""
        import uuid
        
        # 生成embedding
        embedding = await self.embedding_func(content)
        
        # 评估重要性
        importance = self.importance_evaluator(content, metadata or {})
        
        # 创建Memory对象
        memory = Memory(
            id=str(uuid.uuid4()),
            user_id=user_id,
            session_id=session_id,
            memory_type=memory_type,
            content=content,
            embedding=embedding,
            importance=importance,
            metadata=metadata,
            created_at=datetime.now(),
            expires_at=datetime.now() + timedelta(days=ttl_days)
        )
        
        # 异步保存
        memory_id = await self.engine.add_memory(memory)
        
        # 清除相关缓存
        self._invalidate_cache(user_id, session_id)
        
        return memory_id
    
    async def retrieve_memories(
        self,
        query: str,
        user_id: str,
        session_id: Optional[str] = None,
        include_user_memory: bool = True,
        include_ai_memory: bool = True,
        limit: int = 5,
        similarity_threshold: float = 0.7,
        timeout: float = 0.5
    ) -> Dict[str, List[Memory]]:
        """
        检索相关记忆
        
        Returns:
            {
                "user_memories": [...],
                "ai_memories": [...]
            }
        """
        # 检查缓存
        cache_key = self._get_cache_key(user_id, session_id, query)
        if cache_key in self.cache:
            logger.debug(f"Memory cache hit: {cache_key}")
            return self.cache[cache_key]
        
        results = {
            "user_memories": [],
            "ai_memories": []
        }
        
        try:
            # 使用超时控制
            tasks = []
            
            if include_user_memory:
                tasks.append(
                    self.engine.search_memories(
                        query=query,
                        user_id=user_id,
                        session_id=session_id,
                        memory_type=MemoryType.USER,
                        limit=limit,
                        similarity_threshold=similarity_threshold
                    )
                )
            
            if include_ai_memory:
                tasks.append(
                    self.engine.search_memories(
                        query=query,
                        user_id=user_id,
                        session_id=session_id,
                        memory_type=MemoryType.ASSISTANT,
                        limit=limit,
                        similarity_threshold=similarity_threshold
                    )
                )
            
            # 等待所有查询完成（带超时）
            completed = await asyncio.wait_for(
                asyncio.gather(*tasks, return_exceptions=True),
                timeout=timeout
            )
            
            # 处理结果
            if include_user_memory:
                results["user_memories"] = completed[0] if not isinstance(completed[0], Exception) else []
            if include_ai_memory:
                idx = 1 if include_user_memory else 0
                results["ai_memories"] = completed[idx] if not isinstance(completed[idx], Exception) else []
            
            # 缓存结果
            self.cache[cache_key] = results
            
        except asyncio.TimeoutError:
            logger.warning(f"Memory retrieval timeout: {timeout}s")
        except Exception as e:
            logger.error(f"Memory retrieval error: {e}")
        
        return results
    
    def _get_cache_key(self, user_id: str, session_id: Optional[str], query: str) -> str:
        """生成缓存key"""
        import hashlib
        key = f"{user_id}:{session_id or 'all'}:{query}"
        return hashlib.md5(key.encode()).hexdigest()
    
    def _invalidate_cache(self, user_id: str, session_id: str):
        """清除缓存"""
        # 简单实现：清除所有缓存
        self.cache.clear()
        logger.debug(f"Memory cache invalidated for user:{user_id}, session:{session_id}")
```

## 2.4 工具系统 (Tool System)

### 2.4.1 设计目标

1. **统一接口**: 内置工具和MCP工具使用相同接口
2. **自动发现**: MCP服务器的工具自动发现和注册
3. **权限控制**: 按人格配置工具访问权限
4. **并发执行**: 支持多个工具并发调用
5. **错误隔离**: 单个工具失败不影响其他工具

### 2.4.2 工具基类

```python
# app/engines/tools/base.py
from abc import ABC, abstractmethod
from typing import Dict, Any, Optional
from enum import Enum

class ToolType(Enum):
    BUILTIN = "builtin"
    MCP = "mcp"

class Tool(ABC):
    """工具基类"""
    
    def __init__(self):
        self.tool_type = ToolType.BUILTIN
    
    @property
    @abstractmethod
    def name(self) -> str:
        """工具名称"""
        pass
    
    @property
    @abstractmethod
    def description(self) -> str:
        """工具描述"""
        pass
    
    @property
    @abstractmethod
    def parameters(self) -> Dict[str, Any]:
        """工具参数schema"""
        pass
    
    @abstractmethod
    async def execute(self, **kwargs) -> Any:
        """执行工具"""
        pass
    
    def to_openai_function(self) -> Dict[str, Any]:
        """转换为OpenAI function calling格式"""
        return {
            "type": "function",
            "function": {
                "name": self.name,
                "description": self.description,
                "parameters": {
                    "type": "object",
                    "properties": self.parameters,
                    "required": self._get_required_params()
                }
            }
        }
    
    def _get_required_params(self) -> list[str]:
        """获取必需参数列表"""
        return [
            name for name, schema in self.parameters.items()
            if schema.get("required", False)
        ]
```

### 2.4.3 内置工具示例

```python
# app/engines/tools/builtin/web_search.py
from typing import Dict, Any
from app.engines.tools.base import Tool
from tavily import TavilyClient

class WebSearchTool(Tool):
    """网络搜索工具 - 基于Tavily"""
    
    def __init__(self, api_key: str):
        super().__init__()
        self.client = TavilyClient(api_key=api_key)
    
    @property
    def name(self) -> str:
        return "web_search"
    
    @property
    def description(self) -> str:
        return "搜索互联网获取最新信息。适用于需要查询实时数据、新闻、事实性信息的场景。"
    
    @property
    def parameters(self) -> Dict[str, Any]:
        return {
            "query": {
                "type": "string",
                "description": "搜索查询词",
                "required": True
            },
            "max_results": {
                "type": "integer",
                "description": "返回结果数量",
                "default": 5,
                "required": False
            }
        }
    
    async def execute(self, query: str, max_results: int = 5) -> str:
        """执行网络搜索"""
        try:
            response = self.client.search(
                query=query,
                max_results=max_results
            )
            
            # 格式化结果
            results = []
            for i, result in enumerate(response.get('results', []), 1):
                results.append(
                    f"{i}. {result['title']}\n"
                    f"   URL: {result['url']}\n"
                    f"   摘要: {result['content']}\n"
                )
            
            return "\n".join(results) if results else "没有找到相关结果"
            
        except Exception as e:
            return f"搜索失败: {str(e)}"
```

### 2.4.4 MCP工具适配器

```python
# app/engines/tools/mcp/adapters.py
from typing import Dict, Any, List
from app.engines.tools.base import Tool, ToolType
from app.engines.tools.mcp.client import MCPClient

class MCPToolAdapter(Tool):
    """MCP工具适配器 - 将MCP工具适配为统一接口"""
    
    def __init__(
        self,
        mcp_client: MCPClient,
        server_name: str,
        tool_info: Dict[str, Any]
    ):
        super().__init__()
        self.tool_type = ToolType.MCP
        self.mcp_client = mcp_client
        self.server_name = server_name
        self.tool_info = tool_info
        self._name = tool_info['name']
        self._description = tool_info.get('description', '')
        self._parameters = tool_info.get('inputSchema', {}).get('properties', {})
    
    @property
    def name(self) -> str:
        # MCP工具名称格式: {server_name}__{tool_name}
        return f"{self.server_name}__{self._name}"
    
    @property
    def description(self) -> str:
        return self._description
    
    @property
    def parameters(self) -> Dict[str, Any]:
        return self._parameters
    
    async def execute(self, **kwargs) -> Any:
        """执行MCP工具"""
        try:
            result = await self.mcp_client.call_tool(
                self.server_name,
                self._name,
                kwargs
            )
            return result
        except Exception as e:
            return f"MCP工具执行失败: {str(e)}"
```

### 2.4.5 工具管理器

```python
# app/engines/tools/manager.py
from typing import Dict, List, Optional, Any
import asyncio
from app.engines.tools.base import Tool, ToolType
from app.engines.tools.registry import ToolRegistry
from app.utils.logger import logger

class ToolManager:
    """工具管理器"""
    
    def __init__(self, registry: ToolRegistry):
        self.registry = registry
        self.max_concurrent = 3
        self.timeout = 30.0
    
    def get_available_tools(
        self,
        allowed_tools: Optional[List[str]] = None,
        tool_type: Optional[ToolType] = None
    ) -> List[Dict[str, Any]]:
        """
        获取可用工具列表
        
        Args:
            allowed_tools: 允许的工具名称列表（白名单）
            tool_type: 工具类型过滤
        
        Returns:
            工具的OpenAI function格式列表
        """
        tools = self.registry.list_tools(tool_type=tool_type)
        
        # 如果有白名单，过滤
        if allowed_tools:
            tools = [t for t in tools if t.name in allowed_tools]
        
        return [t.to_openai_function() for t in tools]
    
    async def execute_tools(
        self,
        tool_calls: List[Dict[str, Any]]
    ) -> List[Dict[str, Any]]:
        """
        批量执行工具调用
        
        Args:
            tool_calls: OpenAI格式的tool_calls
            
        Returns:
            工具执行结果列表
        """
        # 限制并发数
        semaphore = asyncio.Semaphore(self.max_concurrent)
        
        async def execute_single(tool_call: Dict) -> Dict:
            async with semaphore:
                return await self._execute_single_tool(tool_call)
        
        # 并发执行
        tasks = [execute_single(tc) for tc in tool_calls]
        results = await asyncio.gather(*tasks, return_exceptions=True)
        
        # 处理结果
        formatted_results = []
        for i, result in enumerate(results):
            tool_call = tool_calls[i]
            
            if isinstance(result, Exception):
                formatted_results.append({
                    "role": "tool",
                    "tool_call_id": tool_call.get("id"),
                    "content": f"工具执行出错: {str(result)}"
                })
            else:
                formatted_results.append(result)
        
        return formatted_results
    
    async def _execute_single_tool(self, tool_call: Dict) -> Dict:
        """执行单个工具调用"""
        tool_name = tool_call["function"]["name"]
        tool_call_id = tool_call.get("id")
        
        try:
            # 解析参数
            import json
            params = json.loads(tool_call["function"]["arguments"])
            
            # 获取工具
            tool = self.registry.get_tool(tool_name)
            if not tool:
                raise ValueError(f"Tool not found: {tool_name}")
            
            # 执行工具（带超时）
            result = await asyncio.wait_for(
                tool.execute(**params),
                timeout=self.timeout
            )
            
            logger.info(f"Tool executed: {tool_name}")
            
            return {
                "role": "tool",
                "tool_call_id": tool_call_id,
                "content": str(result)
            }
            
        except asyncio.TimeoutError:
            logger.error(f"Tool execution timeout: {tool_name}")
            return {
                "role": "tool",
                "tool_call_id": tool_call_id,
                "content": f"工具执行超时（{self.timeout}秒）"
            }
        except Exception as e:
            logger.error(f"Tool execution error: {tool_name}, {e}")
            return {
                "role": "tool",
                "tool_call_id": tool_call_id,
                "content": f"工具执行失败: {str(e)}"
            }
```

## 2.5 语音系统 (Voice System)

### 2.5.1 设计目标

1. **多引擎支持**: STT、TTS、RealTime三大引擎，每个引擎支持多提供商
2. **可插拔架构**: 新增提供商只需实现基类接口
3. **统一调用**: 上层调用统一，底层实现透明切换
4. **性能优化**: 音频缓存、并行处理、流式传输

### 2.5.2 STT（语音转文本）引擎

#### STT基类

```python
# app/engines/voice/stt/base.py
from abc import ABC, abstractmethod
from typing import Optional, Dict, Any
from enum import Enum

class STTProvider(Enum):
    OPENAI = "openai"
    TENCENT = "tencent"
    CUSTOM = "custom"

class STTEngineBase(ABC):
    """STT引擎基类"""
    
    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.provider = self._get_provider()
        self.model = config.get("model", "whisper-1")
        self.language = config.get("language", "zh-CN")
    
    @abstractmethod
    def _get_provider(self) -> STTProvider:
        """返回提供商类型"""
        pass
    
    @abstractmethod
    async def transcribe(
        self,
        audio_data: bytes,
        language: Optional[str] = None,
        **kwargs
    ) -> str:
        """
        语音转文本
        
        Args:
            audio_data: 音频数据（bytes）
            language: 语言代码
            **kwargs: 其他参数
        
        Returns:
            str: 识别的文本
        """
        pass
    
    @abstractmethod
    async def health_check(self) -> bool:
        """健康检查"""
        pass
    
    def get_supported_formats(self) -> list[str]:
        """获取支持的音频格式"""
        return ["wav", "mp3", "m4a", "webm", "ogg"]
```

#### OpenAI STT实现

```python
# app/engines/voice/stt/openai_stt.py
from openai import AsyncOpenAI
from typing import Optional, Dict, Any
from app.engines.voice.stt.base import STTEngineBase, STTProvider
from app.utils.logger import logger
import io

class OpenAISTTEngine(STTEngineBase):
    """OpenAI Whisper STT引擎"""
    
    def __init__(self, config: Dict[str, Any]):
        super().__init__(config)
        self.client = AsyncOpenAI(
            api_key=config.get("api_key"),
            base_url=config.get("base_url", "https://api.openai.com/v1"),
            timeout=config.get("timeout", 30.0)
        )
    
    def _get_provider(self) -> STTProvider:
        return STTProvider.OPENAI
    
    async def transcribe(
        self,
        audio_data: bytes,
        language: Optional[str] = None,
        **kwargs
    ) -> str:
        """使用OpenAI Whisper进行语音识别"""
        try:
            # 将bytes转为file-like对象
            audio_file = io.BytesIO(audio_data)
            audio_file.name = "audio.wav"
            
            # 调用Whisper API
            response = await self.client.audio.transcriptions.create(
                model=self.model,
                file=audio_file,
                language=language or self.language,
                response_format="text",
                **kwargs
            )
            
            return response
            
        except Exception as e:
            logger.error(f"OpenAI STT error: {e}")
            raise
    
    async def health_check(self) -> bool:
        """健康检查"""
        try:
            await self.client.models.list()
            return True
        except Exception as e:
            logger.error(f"OpenAI STT health check failed: {e}")
            return False
```

### 2.5.3 TTS（文本转语音）引擎

#### TTS基类

```python
# app/engines/voice/tts/base.py
from abc import ABC, abstractmethod
from typing import Optional, Dict, Any, AsyncIterator
from enum import Enum

class TTSProvider(Enum):
    OPENAI = "openai"
    TENCENT = "tencent"
    CUSTOM = "custom"

class TTSEngineBase(ABC):
    """TTS引擎基类"""
    
    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.provider = self._get_provider()
        self.voice = config.get("voice", "shimmer")
        self.speed = config.get("speed", 1.0)
    
    @abstractmethod
    def _get_provider(self) -> TTSProvider:
        """返回提供商类型"""
        pass
    
    @abstractmethod
    async def synthesize(
        self,
        text: str,
        voice: Optional[str] = None,
        speed: Optional[float] = None,
        **kwargs
    ) -> bytes:
        """文本转语音"""
        pass
    
    @abstractmethod
    async def stream_synthesize(
        self,
        text: str,
        voice: Optional[str] = None,
        speed: Optional[float] = None,
        **kwargs
    ) -> AsyncIterator[bytes]:
        """流式文本转语音"""
        pass
    
    @abstractmethod
    def get_available_voices(self) -> list[str]:
        """获取可用的语音列表"""
        pass
    
    @abstractmethod
    async def health_check(self) -> bool:
        """健康检查"""
        pass
```

### 2.5.4 RealTime（实时语音对话）引擎

详细设计参考OpenAI Realtime API文档。

### 2.5.5 语音引擎工厂

```python
# app/engines/voice/factory.py
from typing import Dict, Any
from app.engines.voice.stt.base import STTEngineBase
from app.engines.voice.tts.base import TTSEngineBase
from app.engines.voice.realtime.base import RealtimeEngineBase

class VoiceEngineFactory:
    """语音引擎工厂"""
    
    @staticmethod
    def create_stt_engine(provider: str, config: Dict[str, Any]) -> STTEngineBase:
        """创建STT引擎"""
        from app.engines.voice.stt.openai_stt import OpenAISTTEngine
        from app.engines.voice.stt.tencent_stt import TencentSTTEngine
        
        engines = {
            "openai": OpenAISTTEngine,
            "tencent": TencentSTTEngine
        }
        
        engine_class = engines.get(provider.lower())
        if not engine_class:
            raise ValueError(f"Unsupported STT provider: {provider}")
        
        return engine_class(config)
    
    @staticmethod
    def create_tts_engine(provider: str, config: Dict[str, Any]) -> TTSEngineBase:
        """创建TTS引擎"""
        from app.engines.voice.tts.openai_tts import OpenAITTSEngine
        
        engines = {
            "openai": OpenAITTSEngine
        }
        
        engine_class = engines.get(provider.lower())
        if not engine_class:
            raise ValueError(f"Unsupported TTS provider: {provider}")
        
        return engine_class(config)
```

## 2.6 用户系统 (User System)

### 2.6.1 用户管理器

```python
# app/core/user/manager.py
from typing import Optional, Dict, Any
from sqlalchemy.orm import Session
from app.models.user import User, UserProfile
from app.core.user.auth import AuthService
from app.utils.logger import logger

class UserManager:
    """用户管理器 - 统一管理用户相关功能"""
    
    def __init__(self, db: Session):
        self.db = db
        self.auth_service = AuthService()
    
    async def register_user(
        self,
        username: str,
        email: str,
        password: str,
        **kwargs
    ) -> User:
        """注册新用户"""
        try:
            # 检查用户名是否存在
            existing = self.db.query(User).filter(
                (User.username == username) | (User.email == email)
            ).first()
            
            if existing:
                raise ValueError("用户名或邮箱已存在")
            
            # 创建用户
            password_hash = self.auth_service.hash_password(password)
            
            user = User(
                username=username,
                email=email,
                password_hash=password_hash,
                role=kwargs.get("role", "user"),
                display_name=kwargs.get("display_name", username)
            )
            
            self.db.add(user)
            self.db.commit()
            self.db.refresh(user)
            
            logger.info(f"User registered: {user.id}")
            return user
            
        except Exception as e:
            self.db.rollback()
            logger.error(f"Failed to register user: {e}")
            raise
    
    async def authenticate(
        self,
        username: str,
        password: str
    ) -> Optional[Dict[str, Any]]:
        """用户认证"""
        try:
            # 查找用户
            user = self.db.query(User).filter(
                (User.username == username) | (User.email == username)
            ).first()
            
            if not user:
                return None
            
            # 验证密码
            if not self.auth_service.verify_password(password, user.password_hash):
                return None
            
            # 生成token
            token = self.auth_service.create_access_token(
                user_id=user.id,
                username=user.username,
                role=user.role
            )
            
            return {
                "access_token": token,
                "token_type": "Bearer",
                "user": {
                    "id": user.id,
                    "username": user.username,
                    "email": user.email,
                    "role": user.role,
                    "preferences": user.preferences
                }
            }
            
        except Exception as e:
            logger.error(f"Authentication error: {e}")
            return None
```

## 2.7 核心编排器 (Core Orchestrator)

### 2.7.1 设计目标

核心编排器是整个系统的大脑，负责协调AI引擎、记忆、工具、语音等模块。

### 2.7.2 编排器实现

```python
# app/core/orchestrator.py
from typing import Dict, Any, List, Optional, AsyncIterator
from app.core.personality.manager import PersonalityManager
from app.engines.ai.factory import AIEngineFactory
from app.engines.memory.manager import MemoryManager
from app.engines.tools.manager import ToolManager
from app.utils.logger import logger
import time

class CoreOrchestrator:
    """
    核心编排器
    
    负责协调所有模块，处理完整的对话流程：
    1. 人格加载
    2. 记忆检索
    3. 工具准备
    4. AI生成
    5. 记忆保存
    """
    
    def __init__(
        self,
        personality_manager: PersonalityManager,
        memory_manager: MemoryManager,
        tool_manager: ToolManager
    ):
        self.personality_manager = personality_manager
        self.memory_manager = memory_manager
        self.tool_manager = tool_manager
        self.ai_engines = {}  # personality_id -> ai_engine
    
    async def process_chat_request(
        self,
        messages: List[Dict[str, str]],
        user_id: str,
        session_id: str,
        personality_id: str,
        stream: bool = False,
        **kwargs
    ) -> AsyncIterator[Dict] | Dict:
        """
        处理聊天请求的核心流程
        
        Args:
            messages: 消息历史
            user_id: 用户ID
            session_id: 会话ID
            personality_id: 人格ID
            stream: 是否流式
            **kwargs: 其他参数
        
        Returns:
            流式: AsyncIterator[Dict]
            非流式: Dict
        """
        start_time = time.time()
        
        # 1. 加载人格配置
        personality = self.personality_manager.get_personality(personality_id)
        if not personality:
            raise ValueError(f"Personality not found: {personality_id}")
        
        logger.info(f"Processing request - personality: {personality.name}")
        
        # 2. 获取或创建AI引擎
        ai_engine = await self._get_or_create_ai_engine(personality)
        
        # 3. 检索相关记忆
        memories = await self._retrieve_memories(
            personality,
            messages,
            user_id,
            session_id
        )
        
        # 4. 构建系统提示（包含记忆）
        system_prompt = self._build_system_prompt(personality, memories)
        
        # 5. 准备工具列表
        tools = await self._prepare_tools(personality)
        
        # 6. 构建完整消息列表
        full_messages = self._build_full_messages(
            system_prompt,
            messages
        )
        
        # 7. 调用AI引擎生成回复
        if stream:
            return self._stream_generate(
                ai_engine,
                full_messages,
                tools,
                user_id,
                session_id,
                personality,
                start_time
            )
        else:
            return await self._generate(
                ai_engine,
                full_messages,
                tools,
                user_id,
                session_id,
                personality,
                start_time
            )
    
    async def _get_or_create_ai_engine(self, personality):
        """获取或创建AI引擎"""
        if personality.id not in self.ai_engines:
            ai_config = personality.config.ai
            engine = AIEngineFactory.create_engine(
                provider=ai_config.provider,
                config=ai_config.to_dict()
            )
            self.ai_engines[personality.id] = engine
        
        return self.ai_engines[personality.id]
    
    def _build_system_prompt(self, personality, memories: Dict) -> str:
        """构建系统提示（包含记忆）"""
        prompt_parts = [personality.config.ai.system_prompt]
        
        # 添加用户记忆
        if memories.get("user_memories"):
            memory_texts = [m.content for m in memories["user_memories"]]
            prompt_parts.append(
                f"\n\n关于用户的记忆：\n" + "\n".join(f"- {text}" for text in memory_texts)
            )
        
        # 添加AI记忆
        if memories.get("ai_memories"):
            memory_texts = [m.content for m in memories["ai_memories"]]
            prompt_parts.append(
                f"\n\n你之前的记录：\n" + "\n".join(f"- {text}" for text in memory_texts)
            )
        
        return "".join(prompt_parts)
```

---

## 3. 总结

本文档详细设计了CozyChat后端的核心模块：

1. **人格系统**: YAML配置驱动，统一管理AI、记忆、工具、语音
2. **AI引擎**: 支持OpenAI、Ollama、LM Studio，可插拔架构
3. **记忆管理**: 区分用户/AI记忆，向量检索，缓存优化
4. **工具系统**: 内置工具 + MCP协议，统一接口
5. **语音系统**: STT、TTS、RealTime三大引擎，多提供商支持
6. **用户系统**: 认证、授权、画像、偏好管理
7. **核心编排器**: 协调所有模块，处理完整对话流程

**下一步**: 参考[04-API接口设计.md](./04-API接口设计.md)了解如何通过API调用这些模块。

---

**文档版本**: v1.0  
**最后更新**: 2025-11-06  
**维护者**: CozyChat Team
