# 删除会话逻辑分析

## 当前实现

### 1. 删除方式：软删除（Soft Delete）

**后端实现**（`backend/app/api/v1/sessions.py:416-481`）：
```python
@router.delete("/{session_id}")
async def delete_session(...):
    """删除会话（软删除）"""
    # 只设置 deleted_at 字段
    session.deleted_at = datetime.utcnow()
    db.commit()
```

**特点**：
- ✅ 会话记录**仍然存在**于数据库中
- ✅ 只是设置了 `deleted_at` 字段（标记为已删除）
- ✅ 可以通过恢复 `deleted_at = NULL` 来恢复会话

### 2. 消息处理

**数据库模型**（`backend/app/models/message.py:42`）：
```python
session_id = Column(
    UUID(as_uuid=True), 
    ForeignKey("sessions.id", ondelete="CASCADE"),  # 级联删除
    nullable=False, 
    index=True
)
```

**问题**：
- ⚠️ `ondelete="CASCADE"` 只在**硬删除**（物理删除）会话时才会触发
- ⚠️ 当前是**软删除**，所以消息**不会被删除**
- ⚠️ 删除会话后，消息仍然存在于数据库中

### 3. 查询过滤

**会话列表查询**（`backend/app/api/v1/sessions.py:195-199`）：
```python
query = db.query(SessionModel).filter(
    and_(
        SessionModel.user_id == user.id,
        SessionModel.deleted_at.is_(None)  # ✅ 过滤已删除的会话
    )
)
```

**会话详情查询**（`backend/app/api/v1/sessions.py:281-286`）：
```python
session = db.query(SessionModel).filter(
    and_(
        SessionModel.id == session_uuid,
        SessionModel.user_id == user.id,
        SessionModel.deleted_at.is_(None)  # ✅ 过滤已删除的会话
    )
).first()
```

**消息查询**（`backend/app/api/v1/sessions.py:296-298`）：
```python
messages = db.query(MessageModel).filter(
    MessageModel.session_id == session_uuid
).order_by(MessageModel.created_at).all()
```

**问题**：
- ⚠️ 消息查询**没有过滤**已删除的会话
- ⚠️ 如果直接通过 `session_id` 查询消息，仍然可以获取到已删除会话的消息

## 当前状态总结

### 删除会话后：

1. **会话表（sessions）**：
   - ✅ 记录存在
   - ✅ `deleted_at` 字段被设置
   - ✅ 查询时被过滤（不会显示在列表中）

2. **消息表（messages）**：
   - ⚠️ **记录仍然存在**
   - ⚠️ **没有被删除**
   - ⚠️ 仍然可以通过 `session_id` 查询到

3. **前端表现**：
   - ✅ 会话从列表中消失
   - ✅ 无法通过正常流程访问
   - ⚠️ 但数据仍在数据库中

## 问题分析

### 问题1：消息没有被删除

**原因**：
- 软删除只设置 `deleted_at`，不会触发数据库的 `CASCADE` 删除
- `ondelete="CASCADE"` 只在物理删除时生效

**影响**：
- 数据库会积累大量"已删除"会话的消息
- 占用存储空间
- 可能影响查询性能

### 问题2：消息查询没有过滤已删除的会话

**原因**：
- 消息查询直接通过 `session_id` 查询，没有检查会话的 `deleted_at`

**影响**：
- 理论上可以通过直接查询消息表获取已删除会话的消息
- 虽然前端不会显示，但数据仍然可访问

## 解决方案

### 方案1：软删除 + 手动删除消息（推荐）

**优点**：
- 保留会话记录（可以恢复）
- 删除消息（节省空间）
- 符合软删除的设计理念

**实现**：
```python
@router.delete("/{session_id}")
async def delete_session(...):
    # 1. 软删除会话
    session.deleted_at = datetime.utcnow()
    
    # 2. 手动删除消息（可选：也使用软删除）
    # 方案A：物理删除消息
    db.query(MessageModel).filter(
        MessageModel.session_id == session_uuid
    ).delete()
    
    # 方案B：软删除消息（如果 Message 表也有 deleted_at 字段）
    # db.query(MessageModel).filter(
    #     MessageModel.session_id == session_uuid
    # ).update({"deleted_at": datetime.utcnow()})
    
    db.commit()
```

### 方案2：硬删除（物理删除）

**优点**：
- 彻底删除，节省空间
- 数据库级联删除自动处理消息

**缺点**：
- 无法恢复
- 不符合软删除的设计理念

**实现**：
```python
@router.delete("/{session_id}")
async def delete_session(...):
    # 物理删除（会触发 CASCADE，自动删除消息）
    db.delete(session)
    db.commit()
```

### 方案3：软删除 + 消息查询过滤

**优点**：
- 保留所有数据（可以恢复）
- 查询时过滤已删除的会话

**缺点**：
- 数据会一直占用空间

**实现**：
```python
# 消息查询时过滤已删除的会话
messages = db.query(MessageModel).join(SessionModel).filter(
    and_(
        MessageModel.session_id == session_uuid,
        SessionModel.deleted_at.is_(None)  # 过滤已删除的会话
    )
).order_by(MessageModel.created_at).all()
```

## 推荐方案

**推荐使用方案1（软删除 + 手动删除消息）**：

1. **会话软删除**：保留会话记录，可以恢复
2. **消息物理删除**：删除消息，节省空间
3. **查询过滤**：确保已删除的会话不会出现在列表中

**理由**：
- 会话可能需要恢复（误删）
- 消息通常不需要恢复（占用空间大）
- 平衡了数据保留和空间占用

## 当前问题

**现状**：
- ✅ 会话软删除（可以恢复）
- ❌ 消息没有被删除（占用空间）
- ⚠️ 消息查询没有过滤已删除的会话

**建议**：
- 修改删除逻辑，删除会话时同时删除消息
- 或者修改消息查询，过滤已删除的会话

