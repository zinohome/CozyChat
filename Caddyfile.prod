www.naivehero.top {
         tls ibmzhangjun@139.com
         encode gzip
         reverse_proxy 192.210.183.125:8090
}
newapi.naivehero.top {
         tls ibmzhangjun@139.com
         encode gzip
         reverse_proxy 192.210.183.125:3000
}
c9.naivehero.top {
         tls ibmzhangjun@139.com
         encode gzip
         reverse_proxy 192.210.183.125:30280
}
desktop.naivehero.top {
         encode gzip
         reverse_proxy 192.210.183.125:6901 {
                  transport http {
                        tls_insecure_skip_verify
                  }
         }
}
1p.naivehero.top {
         encode gzip
         reverse_proxy 192.210.183.125:19984 {
                  transport http {
                           tls
                           tls_insecure_skip_verify
                  }
         }
}
gemini.naivehero.top {
         encode gzip
         reverse_proxy 192.210.183.125:8000 {
                  transport http {
                           tls
                           tls_insecure_skip_verify
                  }
         }
}
yychat.naivehero.top {
         tls ibmzhangjun@139.com
         encode gzip
         # 根路径重定向到指定URL
         @root path /
         redir @root /chat/mTYPopxB99ZemGub 301
    
         reverse_proxy 192.168.240.101:80
}
dify.naivehero.top {
         tls ibmzhangjun@139.com
         encode gzip
         reverse_proxy 192.168.240.101:80
}
yyhelper.naivehero.top {
         tls ibmzhangjun@139.com
         encode gzip
         reverse_proxy 192.168.240.101:8000
}
chat.naivehero.top {
         tls ibmzhangjun@139.com
         encode gzip
         # 普通HTTP请求代理到yyAsistant
         reverse_proxy 192.210.183.125:8000
         # WebSocket请求代理到yychat后端
         handle /ws/* {
             reverse_proxy 192.210.183.125:9800
         }
}

# Caddy 反向代理配置 - OpenAI API
# 域名: oneapi.naivehero.top
# 用途: 代理 OpenAI API 以绕过 GFW 限制，并保护真实的 OpenAI API Key

oneapi.naivehero.top {
    tls ibmzhangjun@139.com
    # 启用日志记录
    log {
        output file /var/log/caddy/access.log
        format json
    }

    # 处理 CORS 预检请求（必须在其他处理之前）
    @cors_preflight {
        method OPTIONS
    }
    handle @cors_preflight {
        header Access-Control-Allow-Origin "*"
        header Access-Control-Allow-Methods "GET, POST, PUT, DELETE, OPTIONS"
        header Access-Control-Allow-Headers "Authorization, Content-Type, X-Requested-With"
        header Access-Control-Max-Age "86400"
        respond 204
    }

    # 匹配使用自定义 API Key 的请求
    # 使用 header 匹配器（简单字符串匹配）
    @custom_key {
        header Authorization "Bearer sk-1s98FFGBvUwEs0uH5yKQDxsxLuv9qNa4P1WadrANek8hh8TH"
    }

    # 处理自定义 Key 的请求：替换为真实的 OpenAI Key
    handle @custom_key {
        reverse_proxy https://api.openai.com {
            # 替换 Authorization header 为真实的 OpenAI API Key
            # 这会覆盖客户端发送的自定义Key，保护真实Key不被暴露
            header_up Authorization "Bearer {$OPENAI_API_KEY}"
            
            # 保持原始主机头
            header_up Host {upstream_hostport}
            
            # 转发其他必要的请求头
            header_up X-Real-IP {remote_host}
            header_up X-Forwarded-For {remote_host}
            header_up X-Forwarded-Proto {scheme}
            
            # WebSocket 支持配置
            # Caddy 2 默认支持 WebSocket，会自动处理 WebSocket 升级
            # 不需要手动转发 WebSocket 相关的请求头，Caddy 会自动处理
            
            # 支持 HTTP/1.1 和 HTTP/2
            # WebSocket 需要 HTTP/1.1，但 Caddy 会自动降级到 HTTP/1.1 用于 WebSocket 连接
            transport http {
                versions 1.1 2
            }
            
            # 3. 健康检查已禁用
            # 注意：OpenAI API 需要认证，健康检查会返回401，导致上游被标记为不可用
            # 如果需要健康检查，可以取消注释下面的配置并添加认证header
            # health_uri /v1/models
            # health_interval 30s
            # health_timeout 5s
            # health_header Authorization "Bearer {$OPENAI_API_KEY}"
            
            # 4. 流式响应设置（用于 SSE 和 WebSocket）
            # -1 表示立即刷新，确保流式数据及时传输
            flush_interval -1
            
            # 注意：Caddy 2 默认支持长时间 WebSocket 连接，无需额外配置超时
            # 对于 OpenAI Realtime API 等长时间运行的 WebSocket 连接，Caddy 会自动保持连接
        }
    }

    # 处理其他请求：拒绝未授权的请求（推荐，更安全）
    # 只允许使用自定义Key的请求通过
    handle {
        respond "Unauthorized: Invalid API Key. Please use the provided custom API key." 401
    }

    # 为所有响应添加 CORS 头（可选，如果需要前端直接访问）
    header {
        Access-Control-Allow-Origin "*"
        Access-Control-Allow-Methods "GET, POST, PUT, DELETE, OPTIONS"
        Access-Control-Allow-Headers "Authorization, Content-Type, X-Requested-With"
    }

}